{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/array.png","path":"images/array.png","modified":0,"renderable":0},{"_id":"source/images/object.png","path":"images/object.png","modified":0,"renderable":0},{"_id":"source/images/value.png","path":"images/value.png","modified":0,"renderable":0},{"_id":"source/images/number.png","path":"images/number.png","modified":0,"renderable":0},{"_id":"source/images/string.png","path":"images/string.png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[10].png","path":"images/About_NavMesh/Image[10].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[11].png","path":"images/About_NavMesh/Image[11].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[12].png","path":"images/About_NavMesh/Image[12].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[13].png","path":"images/About_NavMesh/Image[13].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[14].png","path":"images/About_NavMesh/Image[14].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[16].png","path":"images/About_NavMesh/Image[16].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[1].png","path":"images/About_NavMesh/Image[1].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[20].png","path":"images/About_NavMesh/Image[20].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[21].png","path":"images/About_NavMesh/Image[21].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[23].png","path":"images/About_NavMesh/Image[23].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[22].png","path":"images/About_NavMesh/Image[22].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[24].png","path":"images/About_NavMesh/Image[24].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[25].png","path":"images/About_NavMesh/Image[25].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[26].png","path":"images/About_NavMesh/Image[26].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[27].png","path":"images/About_NavMesh/Image[27].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[28].png","path":"images/About_NavMesh/Image[28].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[29].png","path":"images/About_NavMesh/Image[29].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[2].png","path":"images/About_NavMesh/Image[2].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[30].png","path":"images/About_NavMesh/Image[30].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[31].png","path":"images/About_NavMesh/Image[31].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[3].png","path":"images/About_NavMesh/Image[3].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[4].png","path":"images/About_NavMesh/Image[4].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[9].png","path":"images/About_NavMesh/Image[9].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[8].png","path":"images/About_NavMesh/Image[8].png","modified":0,"renderable":0},{"_id":"themes/alberta/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/alberta/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/alberta/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/alberta/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/alberta/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/alberta/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/alberta/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/alberta/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/alberta/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/alberta/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/alberta/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"source/images/About_NavMesh/Image[15].png","path":"images/About_NavMesh/Image[15].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[19].png","path":"images/About_NavMesh/Image[19].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[5].png","path":"images/About_NavMesh/Image[5].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[7].png","path":"images/About_NavMesh/Image[7].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[6].png","path":"images/About_NavMesh/Image[6].png","modified":0,"renderable":0},{"_id":"themes/alberta/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/alberta/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/alberta/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/alberta/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/alberta/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/alberta/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/alberta/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/alberta/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/alberta/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"source/images/About_NavMesh/Image[17].png","path":"images/About_NavMesh/Image[17].png","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image[18].png","path":"images/About_NavMesh/Image[18].png","modified":0,"renderable":0},{"_id":"source/images/extra_credits.png","path":"images/extra_credits.png","modified":0,"renderable":0},{"_id":"themes/alberta/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"source/images/About_NavMesh/Image_NavigationMeshGeneration.png","path":"images/About_NavMesh/Image_NavigationMeshGeneration.png","modified":0,"renderable":0},{"_id":"themes/alberta/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/alberta/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/files/About_NavMesh/P11_Pedestrian_Reactive_Navigation_for_Crowd_Pedestrian_Reactive_Navigation_for_Crowd_Simulation_a_Predictive_Approach.pdf","path":"files/About_NavMesh/P11_Pedestrian_Reactive_Navigation_for_Crowd_Pedestrian_Reactive_Navigation_for_Crowd_Simulation_a_Predictive_Approach.pdf","modified":0,"renderable":0},{"_id":"source/images/About_NavMesh/Image_RecastAndDetour.png","path":"images/About_NavMesh/Image_RecastAndDetour.png","modified":0,"renderable":0},{"_id":"source/files/About_NavMesh/P1_Conservative_voxelization.pdf","path":"files/About_NavMesh/P1_Conservative_voxelization.pdf","modified":0,"renderable":0},{"_id":"source/files/About_NavMesh/P3_Single-Pass_GPU_Solid_Voxelization_for_Real-Time_Applications.pdf","path":"files/About_NavMesh/P3_Single-Pass_GPU_Solid_Voxelization_for_Real-Time_Applications.pdf","modified":0,"renderable":0},{"_id":"source/files/About_NavMesh/P4_GPU_Gems_2_Chapter_47_Flow_Simulation_with_Complex_Boundaries.pdf","path":"files/About_NavMesh/P4_GPU_Gems_2_Chapter_47_Flow_Simulation_with_Complex_Boundaries.pdf","modified":0,"renderable":0},{"_id":"source/files/About_NavMesh/P7_Volumetric_cell-and-portal_generation.pdf","path":"files/About_NavMesh/P7_Volumetric_cell-and-portal_generation.pdf","modified":0,"renderable":0},{"_id":"source/files/About_NavMesh/P2_Real-time_Voxelization_for_Complex_Models.pdf","path":"files/About_NavMesh/P2_Real-time_Voxelization_for_Complex_Models.pdf","modified":0,"renderable":0},{"_id":"source/files/About_NavMesh/P8_Skeleton_Extraction_of 3D_Objects_with_Visible_Repulsive_Force.pdf","path":"files/About_NavMesh/P8_Skeleton_Extraction_of 3D_Objects_with_Visible_Repulsive_Force.pdf","modified":0,"renderable":0},{"_id":"source/files/About_NavMesh/gdc2006_miles_david_pathplanning.ppt","path":"files/About_NavMesh/gdc2006_miles_david_pathplanning.ppt","modified":0,"renderable":0},{"_id":"source/files/About_NavMesh/P9_Automated_Static_and Dynamic_ObstacleAvoidance_in_Arbitrary_3D_Polygonal_Worlds.pdf","path":"files/About_NavMesh/P9_Automated_Static_and Dynamic_ObstacleAvoidance_in_Arbitrary_3D_Polygonal_Worlds.pdf","modified":0,"renderable":0},{"_id":"source/files/About_NavMesh/P5_GPU_Gems_3_Real-Time_Simulation_and_Rendering_of_3D_Fluids.pdf","path":"files/About_NavMesh/P5_GPU_Gems_3_Real-Time_Simulation_and_Rendering_of_3D_Fluids.pdf","modified":0,"renderable":0},{"_id":"source/files/About_NavMesh/P6_Way-Finder_guided_tours_through_complex_walkthrough_models.pdf","path":"files/About_NavMesh/P6_Way-Finder_guided_tours_through_complex_walkthrough_models.pdf","modified":0,"renderable":0},{"_id":"source/files/About_NavMesh/P10_A_navigation_graph_for_real-time_crowd_animation_on_multilayered_and_uneven_terrain.pdf","path":"files/About_NavMesh/P10_A_navigation_graph_for_real-time_crowd_animation_on_multilayered_and_uneven_terrain.pdf","modified":0,"renderable":0},{"_id":"source/files/About_NavMesh/GDC-06-038.mp3","path":"files/About_NavMesh/GDC-06-038.mp3","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"fcaa73c6f4c46bb68fbf533e1459b046b6efaa1c","modified":1480170794000},{"_id":"themes/alberta/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1471778101000},{"_id":"themes/alberta/README.md","hash":"26eae3c3d94176cbc7a0a1a3b93ab777c149b890","modified":1471778101000},{"_id":"themes/alberta/_config.yml","hash":"6972e5459de14fd3c532821936fda6556067293c","modified":1480179629000},{"_id":"source/_posts/Survival_Skill_Markdown_and_Latex_Formulas.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480177167000},{"_id":"source/_posts/A_New_Begin.md","hash":"04846887b692badd7385185fedd5100ddd0c3058","modified":1480178847000},{"_id":"source/_posts/A_New_Blog.md","hash":"11d7980e840542383eee2ce2bb13f38a4e5315bf","modified":1480178809000},{"_id":"source/_posts/A_Quick_Introduction_to_NavMesh.md","hash":"5b547e25418ad7e83fc9f2cf96f5ec821f54451a","modified":1475342688000},{"_id":"source/_posts/About_IAP_Receipt.md","hash":"79d04caaee4d784933c4aa5f515ea06814528597","modified":1470656579000},{"_id":"source/About/index.md","hash":"03e85e08e9cd0a542be55e795d1f40c3290af321","modified":1470656579000},{"_id":"source/_posts/.DS_Store","hash":"12fb2af229ec792ca60408703b6b966305eb6ba5","modified":1480170794000},{"_id":"source/_posts/About_NavMesh.md","hash":"ddab144625f55e0944bcdbed0a83a1a078e4fb8d","modified":1475342688000},{"_id":"source/_posts/Black_Magic_Flash_iOS_ANE.md","hash":"0b87f0f9a7928f7d69d41b3f40abc098c0a84b85","modified":1470656579000},{"_id":"source/_posts/Black_Magic_Xcode_Plugin.md","hash":"f672ecb0d5e8c70b02ae259efc6bcf6a60540a52","modified":1470656579000},{"_id":"source/_posts/Extra_Credits.md","hash":"493820d66ccb2dca28450efb206c28e82ae9c4a6","modified":1480178876000},{"_id":"source/_posts/Homework_Lua.md","hash":"f51768211717b511fb40cc50778c5b9b5e671fac","modified":1480178882000},{"_id":"source/_posts/U3D_iOS_Wrapper.md","hash":"a8b1b0e437b378990eb5d1d0092df8bce28e9d6f","modified":1470656579000},{"_id":"source/files/.DS_Store","hash":"721632e142e65577d895508e995b4b256d29a8c1","modified":1471778369000},{"_id":"source/images/array.png","hash":"6e965355b514d13be64704750ef32ccdbf373b7b","modified":1470656579000},{"_id":"source/images/object.png","hash":"ec9c986a27bd218e78dccba8d6993a4fd322445d","modified":1470656579000},{"_id":"source/images/value.png","hash":"8ac93e46151a00d5449c16951b5586c2529750b3","modified":1470656579000},{"_id":"themes/alberta/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1471778101000},{"_id":"themes/alberta/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1471778101000},{"_id":"themes/alberta/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1471778101000},{"_id":"themes/alberta/layout/layout.ejs","hash":"d4cc7b89830b99ca9f29f7ec8e00ac7d6ef6f438","modified":1471778101000},{"_id":"themes/alberta/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1471778101000},{"_id":"themes/alberta/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1471778101000},{"_id":"themes/alberta/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1471778101000},{"_id":"themes/alberta/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1471778101000},{"_id":"source/images/number.png","hash":"de2bd925b5b8ea43033143c6ad8479f27aa474c9","modified":1470656579000},{"_id":"source/images/string.png","hash":"6299d8bae92a75dbbb5f01975dec7813fc0d507b","modified":1470656579000},{"_id":"themes/alberta/layout/_partial/mobile-nav.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1471778101000},{"_id":"source/files/About_NavMesh/.DS_Store","hash":"3fcc85da03ee3ba2b82cd377933563cab49e0141","modified":1471776371000},{"_id":"source/images/About_NavMesh/Image[10].png","hash":"edcdea707e0804e3dfe58b604bd872a4094e31d9","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[11].png","hash":"5441d4912f9a3500dfc7810fd8c880681e1d2732","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[12].png","hash":"94fabbb0941034d45c298dafabcdc8ab6aee15f6","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[13].png","hash":"a858b4cd6f8b0a9d30d797e5662796a5608dc221","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[14].png","hash":"b57e13ddafe1a372ab7079e43f31288da0fca006","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[16].png","hash":"0e87b4814414f1ffbd7d37e866dad4bf50ae54f5","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[1].png","hash":"d12fd9ace5343ea56a8a303fd942a64e45c0d82a","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[20].png","hash":"f622dac114a7f7f46e4034d2bdc2243f117bafd6","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[21].png","hash":"12a89f76e6258e07896cdb7ae3a2512e9ff69c34","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[23].png","hash":"aa158a8d0994203ee7369dfa15d22f422563ebc9","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[22].png","hash":"3158e6d034020082cda4b9f620ba03e61ac05e02","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[24].png","hash":"483e8d48d0de6a229f4d486a949c16a310df9fa0","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[25].png","hash":"66e0f9465435669512030a4c753a5d2a0929b851","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[26].png","hash":"21fd78b6a323ac0228e465aab7d980557a6babd0","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[27].png","hash":"554fb9ad5b571647bee758b0b4f6603e44aaaf90","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[28].png","hash":"9852b02ba4d210a9c4fd70278e9ecb8f510a27d5","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[29].png","hash":"8ae85a9fcc858919e9a1a0f1769ed687478a486a","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[2].png","hash":"7e271711e951cdb85c36455f7f4c319478e10012","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[30].png","hash":"ec7d6a1504c5056b70142d0b089c90be49055caa","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[31].png","hash":"de089c9be66c4bc150b17e634ca3978e51e80892","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[3].png","hash":"dbe89b0525365e8ad635e3047698f64afa6fc2fe","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[4].png","hash":"7515672901918763480e6d4e4e4d281745975e9b","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[9].png","hash":"5e224f414f9585afabbed7b8e393abbc6b7fa9d6","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[8].png","hash":"6ff69789d7bad407c686e9b308328c9a2c86d44c","modified":1471773100000},{"_id":"themes/alberta/layout/_partial/after-footer.ejs","hash":"70b6c4cd6a88383ec10586c03cfdf11c170c66ca","modified":1471778101000},{"_id":"themes/alberta/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1471778101000},{"_id":"themes/alberta/layout/_partial/archive.ejs","hash":"d7de6421497ffaf65e4f5fe4bed71fcea51fde80","modified":1471778101000},{"_id":"themes/alberta/layout/_partial/article.ejs","hash":"ab4ac8775ebb81679c9b9080c8f83370330ccbcc","modified":1471778101000},{"_id":"themes/alberta/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1471778101000},{"_id":"themes/alberta/layout/_partial/footer.ejs","hash":"2ff5b9e497d490d50ae23fb3cca3fda1b2254db2","modified":1471778101000},{"_id":"themes/alberta/layout/_partial/header.ejs","hash":"a3c2dd681064e9a0ea8b2983d7654f0d6e6dcfc8","modified":1471778101000},{"_id":"themes/alberta/layout/_partial/head.ejs","hash":"92e18018d1e79b57676d9e98a7fd476afb0b38b4","modified":1471778101000},{"_id":"themes/alberta/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1471778101000},{"_id":"themes/alberta/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1471778101000},{"_id":"themes/alberta/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1471778101000},{"_id":"themes/alberta/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1471778101000},{"_id":"themes/alberta/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1471778101000},{"_id":"themes/alberta/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1471778101000},{"_id":"themes/alberta/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1471778101000},{"_id":"themes/alberta/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1471778101000},{"_id":"themes/alberta/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1471778101000},{"_id":"themes/alberta/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1471778101000},{"_id":"themes/alberta/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1471778101000},{"_id":"themes/alberta/source/css/_variables.styl","hash":"8ab598beb56648fdf763c8731c5538661dce204f","modified":1471778101000},{"_id":"themes/alberta/source/css/style.styl","hash":"db96256555b637f9bfe5df6a0da0d3d21b53f0c2","modified":1471778101000},{"_id":"source/images/About_NavMesh/Image[15].png","hash":"ca4df9b22b6715a2a7285a132965f0549fad049e","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[19].png","hash":"6891129c9ea5d053d131d6aa49430eec0d14f935","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[5].png","hash":"c1a96e42638b0264181eaecc5dd482d06faafa13","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[7].png","hash":"bdaa3aa99ad15ac06411afb27ae08f2867ee5092","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[6].png","hash":"40dcc34c2ad59d9534c7a9cba0f3704b852e86ec","modified":1471773100000},{"_id":"themes/alberta/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1471778101000},{"_id":"themes/alberta/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1471778101000},{"_id":"themes/alberta/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1471778101000},{"_id":"themes/alberta/layout/_partial/post/nav.ejs","hash":"f26d30355ba9144c51e700e8edc6a4ab6144ff9a","modified":1471778101000},{"_id":"themes/alberta/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1471778101000},{"_id":"themes/alberta/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1471778101000},{"_id":"themes/alberta/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1471778101000},{"_id":"themes/alberta/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1471778101000},{"_id":"themes/alberta/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1471778101000},{"_id":"themes/alberta/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1471778101000},{"_id":"themes/alberta/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1471778101000},{"_id":"themes/alberta/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1471778101000},{"_id":"themes/alberta/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1471778101000},{"_id":"themes/alberta/source/css/_partial/article.styl","hash":"9763d2325cabb56c5360345fdc2424346e4c45eb","modified":1471778101000},{"_id":"themes/alberta/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1471778101000},{"_id":"themes/alberta/source/css/_partial/footer.styl","hash":"b45dcda3db2daf4389a300c5865976e085bc938b","modified":1471778101000},{"_id":"themes/alberta/source/css/_partial/header.styl","hash":"42b5cfc8bf0c27624509b8e0f857960de0376dec","modified":1471778101000},{"_id":"themes/alberta/source/css/_partial/highlight.styl","hash":"36eefe6332b86b66023a9884b754d305235846b4","modified":1471778101000},{"_id":"themes/alberta/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1471778101000},{"_id":"themes/alberta/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1471778101000},{"_id":"themes/alberta/source/css/_partial/sidebar-bottom.styl","hash":"bc5487b9a0bfe5f745423331824d3f3637ccd430","modified":1471778101000},{"_id":"themes/alberta/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1471778101000},{"_id":"themes/alberta/source/css/_partial/sidebar.styl","hash":"b7bdc11effa98c6d88850eff75634e2ea9207c14","modified":1471778101000},{"_id":"themes/alberta/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1471778101000},{"_id":"themes/alberta/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1471778101000},{"_id":"themes/alberta/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1471778101000},{"_id":"themes/alberta/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1471778101000},{"_id":"source/images/About_NavMesh/Image[17].png","hash":"9eb4d682a5b69e957322110f38dbb3657555b4bb","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image[18].png","hash":"43c43da0e5d8806b81c7ae232eab86e29498f59c","modified":1471773100000},{"_id":"source/images/extra_credits.png","hash":"1a2003845b8f0ab9f04678395953d31f6071a6fa","modified":1470656579000},{"_id":"themes/alberta/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1471778101000},{"_id":"source/images/About_NavMesh/Image_NavigationMeshGeneration.png","hash":"e0fc2b372938787389636cb86080b242df716421","modified":1471773100000},{"_id":"themes/alberta/source/css/images/banner.jpg","hash":"843d9d47bf2b7b75495db11b3d765efaaae442a9","modified":1471778101000},{"_id":"themes/alberta/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1471778101000},{"_id":"source/files/About_NavMesh/P11_Pedestrian_Reactive_Navigation_for_Crowd_Pedestrian_Reactive_Navigation_for_Crowd_Simulation_a_Predictive_Approach.pdf","hash":"eeeb6379c60e61669f058041b4cb0f15f6d17c4a","modified":1471773100000},{"_id":"source/images/About_NavMesh/Image_RecastAndDetour.png","hash":"07592738ef7ab84d1806c0fe1df5b7f8e62bb99d","modified":1471773100000},{"_id":"source/files/About_NavMesh/P1_Conservative_voxelization.pdf","hash":"d4a27ccc5d66bfee7406ffcf29d18ff1837f2d1c","modified":1471773100000},{"_id":"source/files/About_NavMesh/P3_Single-Pass_GPU_Solid_Voxelization_for_Real-Time_Applications.pdf","hash":"37ad6b4fb1ed0b6ae61f43145eaf33479b1aab16","modified":1471773100000},{"_id":"source/files/About_NavMesh/P4_GPU_Gems_2_Chapter_47_Flow_Simulation_with_Complex_Boundaries.pdf","hash":"7681455049e3ae269aef544e906c82ef5858f524","modified":1471774453000},{"_id":"source/files/About_NavMesh/P7_Volumetric_cell-and-portal_generation.pdf","hash":"a05ebfe99369a3ff1c8f5a0134fb4966181a0154","modified":1471773100000},{"_id":"source/files/About_NavMesh/P2_Real-time_Voxelization_for_Complex_Models.pdf","hash":"b37384bb0602c0660794bebc60d23cf5adc543b7","modified":1471773100000},{"_id":"source/files/About_NavMesh/P8_Skeleton_Extraction_of 3D_Objects_with_Visible_Repulsive_Force.pdf","hash":"a5b68a44309dcd4e36510becf85eb54bcde39942","modified":1471773100000},{"_id":"source/files/About_NavMesh/gdc2006_miles_david_pathplanning.ppt","hash":"5df89e6dfe0de1d17c913d1475ce46542efc8931","modified":1471773100000},{"_id":"source/files/About_NavMesh/P9_Automated_Static_and Dynamic_ObstacleAvoidance_in_Arbitrary_3D_Polygonal_Worlds.pdf","hash":"f6149f223531e626c861923e4369d01be2291f13","modified":1471773100000},{"_id":"source/files/About_NavMesh/P5_GPU_Gems_3_Real-Time_Simulation_and_Rendering_of_3D_Fluids.pdf","hash":"63d106471fc6fe6b8b13090a6cc06353751ec815","modified":1471773100000},{"_id":"source/files/About_NavMesh/P6_Way-Finder_guided_tours_through_complex_walkthrough_models.pdf","hash":"62e925e900e4bee406783db01973a417d846715e","modified":1471773100000},{"_id":"source/files/About_NavMesh/P10_A_navigation_graph_for_real-time_crowd_animation_on_multilayered_and_uneven_terrain.pdf","hash":"77af696497a01f0fca294feea9c792b9a95f14c1","modified":1471773100000},{"_id":"source/files/About_NavMesh/GDC-06-038.mp3","hash":"31a573e91b62eb7562b5bc032391368e8d944b0c","modified":1471773099000},{"_id":"source/_posts/Survival_Skill_Markdown_and_LaTex_Formulas.md","hash":"e7b4ae13cb8b9c92233ab9ced23f2410f2f1c8b1","modified":1480178955000},{"_id":"public/About/index.html","hash":"0190ad3385f07bc78f285105795620a67f79f9ac","modified":1480179642095},{"_id":"public/2016/11/27/Survival_Skill_Markdown_and_LaTex_Formulas/index.html","hash":"2822224b2664e283ebc53855af21408f9549e72f","modified":1480179642095},{"_id":"public/2016/08/21/About_NavMesh/index.html","hash":"7771877ff38ff0abb297f4bb4627441d4058e96a","modified":1480179642096},{"_id":"public/2014/11/28/A_New_Begin/index.html","hash":"0b47214cc14dadabe578431370acc9a9f638655b","modified":1480179642096},{"_id":"public/2014/11/27/Extra_Credits/index.html","hash":"6f85af3c233f32e32c665389cf0a9189118205e4","modified":1480179642096},{"_id":"public/2014/11/24/Black_Magic_Xcode_Plugin/index.html","hash":"a2c8e9c503123926e2604ad74f4703dedc01612e","modified":1480179642097},{"_id":"public/2014/08/17/About_IAP_Receipt/index.html","hash":"a1f7c1c2448bd5ff3bcf664d2697203a461a1826","modified":1480179642097},{"_id":"public/2014/08/17/U3D_iOS_Wrapper/index.html","hash":"8e2a4af4b0fe928099252796c8b15c28e26922d0","modified":1480179642097},{"_id":"public/2014/07/17/A_New_Blog/index.html","hash":"2c1e51a2765a47e66aaf7c997139184f61e73556","modified":1480179642097},{"_id":"public/archives/index.html","hash":"a985fecc4253e2e016105ba06c12fa724a204e06","modified":1480179642097},{"_id":"public/archives/page/2/index.html","hash":"eda07a2548a0b946dd35ba7a055c4e426b0073b1","modified":1480179642097},{"_id":"public/archives/2014/index.html","hash":"2f7265305fa2da55d17f3b4ef7187ed5874f918e","modified":1480179642097},{"_id":"public/archives/2014/07/index.html","hash":"6c3e8c7524b97d7dbbf8b385f5ca714d3543eaf5","modified":1480179642097},{"_id":"public/archives/2014/08/index.html","hash":"b9b58c8d4ce815596a3283fb8150139fb17f921b","modified":1480179642097},{"_id":"public/archives/2014/11/index.html","hash":"7e563f33356a3ee11ce0eafd9cf02f2fcf12b6ad","modified":1480179642097},{"_id":"public/archives/2015/index.html","hash":"63396cb8ae124fca55b73ecf7270e3003de43767","modified":1480179642098},{"_id":"public/archives/2015/01/index.html","hash":"2a395c553100efea4a537ea3d19f3a1c0a05d6f3","modified":1480179642098},{"_id":"public/archives/2016/index.html","hash":"dbfc773ee7f1dab2a76b7b3f53852215eaaafc76","modified":1480179642098},{"_id":"public/archives/2016/08/index.html","hash":"67c7e93e4d183360d574bbc8d2949fba5caa7f68","modified":1480179642098},{"_id":"public/archives/2016/11/index.html","hash":"c568b3b996e1110e6dcd5c0076796a7ed3599552","modified":1480179642098},{"_id":"public/page/2/index.html","hash":"2500ad24ac87ce3f03f84d9e496dc3597607d5a1","modified":1480179642098},{"_id":"public/tags/Game/index.html","hash":"06589b3a95ac0b88e15e47a1b9d77f17c266b8bd","modified":1480179642099},{"_id":"public/tags/Work/index.html","hash":"bd678948ca29996106da55491d6bf204349c257c","modified":1480179642099},{"_id":"public/tags/Recast-Detour/index.html","hash":"4703b582031161ce07c6dc7d5bac1a8bcc7b0188","modified":1480179642099},{"_id":"public/tags/NavMesh/index.html","hash":"c2773e5dd1b3eb0a5b6ee8648d3886a1dfe1ed49","modified":1480179642099},{"_id":"public/tags/iOS/index.html","hash":"3e900ee1b7ba4210203fdb027657504d3e2e4690","modified":1480179642099},{"_id":"public/tags/IAP/index.html","hash":"3ac5c493e68b9b3fdaf5eaefc33de6dcf3fe3eed","modified":1480179642099},{"_id":"public/tags/Receipt/index.html","hash":"604d52b95edb81538843d07a6b79adacedbee63a","modified":1480179642099},{"_id":"public/tags/SDK/index.html","hash":"51dec54d4cf8e50d7575d870a2f7990afb527590","modified":1480179642099},{"_id":"public/tags/Flash/index.html","hash":"7dc1fe41c242efbc4101e722a5464024abbb83fd","modified":1480179642099},{"_id":"public/tags/ANE/index.html","hash":"2ad94ff73786b7acd4f285a1d0783c7d5cbce44a","modified":1480179642099},{"_id":"public/tags/Xcode/index.html","hash":"fc2ebdc3396451a06e8aa9e4f83ac2789a7f9cc2","modified":1480179642099},{"_id":"public/tags/Plugin/index.html","hash":"c11243a94fee3c14b35534d49ae64f0ea4517abc","modified":1480179642099},{"_id":"public/tags/Extra-Credits/index.html","hash":"c48d3990d7e197a6cac5a335eca1fd6835e708ae","modified":1480179642099},{"_id":"public/tags/lua/index.html","hash":"465807317b5f5d7c76ed8de76d0e9344b196aa84","modified":1480179642100},{"_id":"public/tags/json/index.html","hash":"75ec46a8cf586439f07b981228ea117c15edead0","modified":1480179642100},{"_id":"public/tags/U3D/index.html","hash":"3261f8ae0cf3910610bdfd891010af2727e7d9c1","modified":1480179642100},{"_id":"public/tags/daily/index.html","hash":"ddcf525e91ef420121a926e9668ff7f2f60d9e67","modified":1480179642100},{"_id":"public/tags/Video-Lesson-Series/index.html","hash":"1110d4f2ad4b9ac68eed08d429a6c25ab0c019cf","modified":1480179642100},{"_id":"public/tags/Parser/index.html","hash":"75242d1082d21eb03b28c25a4d2ecda4ac78c91e","modified":1480179642100},{"_id":"public/tags/Survival-Skill/index.html","hash":"53d7e716ab3cfc61f7649ae07e6fcf8ac118eedf","modified":1480179642100},{"_id":"public/tags/Markdown/index.html","hash":"5f5e133f468648c82460dcd0edfcd551079f0a63","modified":1480179642100},{"_id":"public/tags/LaTex/index.html","hash":"748b841dcdcc32e872274a10df7653146b421e78","modified":1480179642100},{"_id":"public/2016/08/21/A_Quick_Introduction_to_NavMesh/index.html","hash":"ce4c54512ad005ef81f440aab30c883fe94dee08","modified":1480179642100},{"_id":"public/2015/01/09/Homework_Lua/index.html","hash":"e082b33a93798bd8ad4283ee9d3fde8e8647e22f","modified":1480179642100},{"_id":"public/2014/08/15/Black_Magic_Flash_iOS_ANE/index.html","hash":"1a166c594623fdc30822e76bafaff14ec86e5513","modified":1480179642100},{"_id":"public/index.html","hash":"cd037e2d822744cb724da0f7c5edf3879aa4689f","modified":1480179642100},{"_id":"public/images/array.png","hash":"6e965355b514d13be64704750ef32ccdbf373b7b","modified":1480179453539},{"_id":"public/images/object.png","hash":"ec9c986a27bd218e78dccba8d6993a4fd322445d","modified":1480179453539},{"_id":"public/images/value.png","hash":"8ac93e46151a00d5449c16951b5586c2529750b3","modified":1480179453539},{"_id":"public/images/About_NavMesh/Image[10].png","hash":"edcdea707e0804e3dfe58b604bd872a4094e31d9","modified":1480179453539},{"_id":"public/images/About_NavMesh/Image[11].png","hash":"5441d4912f9a3500dfc7810fd8c880681e1d2732","modified":1480179453540},{"_id":"public/images/About_NavMesh/Image[12].png","hash":"94fabbb0941034d45c298dafabcdc8ab6aee15f6","modified":1480179453540},{"_id":"public/images/About_NavMesh/Image[13].png","hash":"a858b4cd6f8b0a9d30d797e5662796a5608dc221","modified":1480179453540},{"_id":"public/images/About_NavMesh/Image[14].png","hash":"b57e13ddafe1a372ab7079e43f31288da0fca006","modified":1480179453540},{"_id":"public/images/About_NavMesh/Image[16].png","hash":"0e87b4814414f1ffbd7d37e866dad4bf50ae54f5","modified":1480179453540},{"_id":"public/images/About_NavMesh/Image[1].png","hash":"d12fd9ace5343ea56a8a303fd942a64e45c0d82a","modified":1480179453540},{"_id":"public/images/About_NavMesh/Image[20].png","hash":"f622dac114a7f7f46e4034d2bdc2243f117bafd6","modified":1480179453540},{"_id":"public/images/About_NavMesh/Image[21].png","hash":"12a89f76e6258e07896cdb7ae3a2512e9ff69c34","modified":1480179453540},{"_id":"public/images/About_NavMesh/Image[23].png","hash":"aa158a8d0994203ee7369dfa15d22f422563ebc9","modified":1480179453540},{"_id":"public/images/About_NavMesh/Image[22].png","hash":"3158e6d034020082cda4b9f620ba03e61ac05e02","modified":1480179453540},{"_id":"public/images/About_NavMesh/Image[24].png","hash":"483e8d48d0de6a229f4d486a949c16a310df9fa0","modified":1480179453540},{"_id":"public/images/About_NavMesh/Image[25].png","hash":"66e0f9465435669512030a4c753a5d2a0929b851","modified":1480179453540},{"_id":"public/images/About_NavMesh/Image[26].png","hash":"21fd78b6a323ac0228e465aab7d980557a6babd0","modified":1480179453540},{"_id":"public/images/About_NavMesh/Image[27].png","hash":"554fb9ad5b571647bee758b0b4f6603e44aaaf90","modified":1480179453541},{"_id":"public/images/About_NavMesh/Image[28].png","hash":"9852b02ba4d210a9c4fd70278e9ecb8f510a27d5","modified":1480179453541},{"_id":"public/images/About_NavMesh/Image[29].png","hash":"8ae85a9fcc858919e9a1a0f1769ed687478a486a","modified":1480179453541},{"_id":"public/images/About_NavMesh/Image[2].png","hash":"7e271711e951cdb85c36455f7f4c319478e10012","modified":1480179453541},{"_id":"public/images/About_NavMesh/Image[30].png","hash":"ec7d6a1504c5056b70142d0b089c90be49055caa","modified":1480179453541},{"_id":"public/images/About_NavMesh/Image[31].png","hash":"de089c9be66c4bc150b17e634ca3978e51e80892","modified":1480179453541},{"_id":"public/images/About_NavMesh/Image[3].png","hash":"dbe89b0525365e8ad635e3047698f64afa6fc2fe","modified":1480179453541},{"_id":"public/images/About_NavMesh/Image[4].png","hash":"7515672901918763480e6d4e4e4d281745975e9b","modified":1480179453541},{"_id":"public/images/About_NavMesh/Image[9].png","hash":"5e224f414f9585afabbed7b8e393abbc6b7fa9d6","modified":1480179453541},{"_id":"public/images/About_NavMesh/Image[8].png","hash":"6ff69789d7bad407c686e9b308328c9a2c86d44c","modified":1480179453541},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1480179453541},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1480179453541},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1480179453541},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1480179453541},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1480179453541},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1480179453542},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1480179453542},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1480179453542},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1480179453542},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1480179453542},{"_id":"public/images/number.png","hash":"de2bd925b5b8ea43033143c6ad8479f27aa474c9","modified":1480179454425},{"_id":"public/images/string.png","hash":"6299d8bae92a75dbbb5f01975dec7813fc0d507b","modified":1480179454426},{"_id":"public/images/About_NavMesh/Image[15].png","hash":"ca4df9b22b6715a2a7285a132965f0549fad049e","modified":1480179454428},{"_id":"public/images/About_NavMesh/Image[19].png","hash":"6891129c9ea5d053d131d6aa49430eec0d14f935","modified":1480179454428},{"_id":"public/images/About_NavMesh/Image[5].png","hash":"c1a96e42638b0264181eaecc5dd482d06faafa13","modified":1480179454428},{"_id":"public/images/About_NavMesh/Image[7].png","hash":"bdaa3aa99ad15ac06411afb27ae08f2867ee5092","modified":1480179454428},{"_id":"public/images/About_NavMesh/Image[6].png","hash":"40dcc34c2ad59d9534c7a9cba0f3704b852e86ec","modified":1480179454429},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1480179454429},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1480179454437},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1480179454437},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1480179454437},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1480179454437},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1480179454437},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1480179454437},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1480179454438},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1480179454438},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1480179454438},{"_id":"public/css/style.css","hash":"43449dab7e5dc0d37a703d9fd3ca431c29f10948","modified":1480179454438},{"_id":"public/images/About_NavMesh/Image[17].png","hash":"9eb4d682a5b69e957322110f38dbb3657555b4bb","modified":1480179454450},{"_id":"public/images/About_NavMesh/Image[18].png","hash":"43c43da0e5d8806b81c7ae232eab86e29498f59c","modified":1480179454450},{"_id":"public/css/images/banner.jpg","hash":"843d9d47bf2b7b75495db11b3d765efaaae442a9","modified":1480179454450},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1480179454450},{"_id":"public/images/extra_credits.png","hash":"1a2003845b8f0ab9f04678395953d31f6071a6fa","modified":1480179454472},{"_id":"public/images/About_NavMesh/Image_NavigationMeshGeneration.png","hash":"e0fc2b372938787389636cb86080b242df716421","modified":1480179454472},{"_id":"public/files/About_NavMesh/P11_Pedestrian_Reactive_Navigation_for_Crowd_Pedestrian_Reactive_Navigation_for_Crowd_Simulation_a_Predictive_Approach.pdf","hash":"eeeb6379c60e61669f058041b4cb0f15f6d17c4a","modified":1480179454488},{"_id":"public/images/About_NavMesh/Image_RecastAndDetour.png","hash":"07592738ef7ab84d1806c0fe1df5b7f8e62bb99d","modified":1480179454488},{"_id":"public/files/About_NavMesh/P1_Conservative_voxelization.pdf","hash":"d4a27ccc5d66bfee7406ffcf29d18ff1837f2d1c","modified":1480179454507},{"_id":"public/files/About_NavMesh/P3_Single-Pass_GPU_Solid_Voxelization_for_Real-Time_Applications.pdf","hash":"37ad6b4fb1ed0b6ae61f43145eaf33479b1aab16","modified":1480179454509},{"_id":"public/files/About_NavMesh/P4_GPU_Gems_2_Chapter_47_Flow_Simulation_with_Complex_Boundaries.pdf","hash":"7681455049e3ae269aef544e906c82ef5858f524","modified":1480179454513},{"_id":"public/files/About_NavMesh/P7_Volumetric_cell-and-portal_generation.pdf","hash":"a05ebfe99369a3ff1c8f5a0134fb4966181a0154","modified":1480179454513},{"_id":"public/files/About_NavMesh/P2_Real-time_Voxelization_for_Complex_Models.pdf","hash":"b37384bb0602c0660794bebc60d23cf5adc543b7","modified":1480179454516},{"_id":"public/files/About_NavMesh/P8_Skeleton_Extraction_of 3D_Objects_with_Visible_Repulsive_Force.pdf","hash":"a5b68a44309dcd4e36510becf85eb54bcde39942","modified":1480179454518},{"_id":"public/files/About_NavMesh/gdc2006_miles_david_pathplanning.ppt","hash":"5df89e6dfe0de1d17c913d1475ce46542efc8931","modified":1480179454522},{"_id":"public/files/About_NavMesh/P9_Automated_Static_and Dynamic_ObstacleAvoidance_in_Arbitrary_3D_Polygonal_Worlds.pdf","hash":"f6149f223531e626c861923e4369d01be2291f13","modified":1480179454522},{"_id":"public/files/About_NavMesh/P5_GPU_Gems_3_Real-Time_Simulation_and_Rendering_of_3D_Fluids.pdf","hash":"63d106471fc6fe6b8b13090a6cc06353751ec815","modified":1480179454536},{"_id":"public/files/About_NavMesh/P6_Way-Finder_guided_tours_through_complex_walkthrough_models.pdf","hash":"62e925e900e4bee406783db01973a417d846715e","modified":1480179454548},{"_id":"public/files/About_NavMesh/P10_A_navigation_graph_for_real-time_crowd_animation_on_multilayered_and_uneven_terrain.pdf","hash":"77af696497a01f0fca294feea9c792b9a95f14c1","modified":1480179454557},{"_id":"public/files/About_NavMesh/GDC-06-038.mp3","hash":"31a573e91b62eb7562b5bc032391368e8d944b0c","modified":1480179454621}],"Category":[{"name":"a","_id":"civzfqikx0006f66obdt2nwfg"}],"Data":[],"Page":[{"title":"About","_content":"\n\n{% code ME lang:json %}\n\n{ \n  \"id\": \"wo1fSea\", \n  \"name\": [\"黄铨雍\", \"Quanyong Huang\"], \n  \"major\": \"CS\",\n  \"language\": [\"潮州话\",\"普通话\",\"English\",\"c/c++\"],\n  \"contact\": \n    { \n      \"qq\": 5337338, \n      \"email\": \"quanyongh@foxmail.com\", \n      \"wechat\": \"huangquanyong\"\n    } \n}\n\n{% endcode %}\n","source":"About/index.md","raw":"title: About\n---\n\n\n{% code ME lang:json %}\n\n{ \n  \"id\": \"wo1fSea\", \n  \"name\": [\"黄铨雍\", \"Quanyong Huang\"], \n  \"major\": \"CS\",\n  \"language\": [\"潮州话\",\"普通话\",\"English\",\"c/c++\"],\n  \"contact\": \n    { \n      \"qq\": 5337338, \n      \"email\": \"quanyongh@foxmail.com\", \n      \"wechat\": \"huangquanyong\"\n    } \n}\n\n{% endcode %}\n","date":"2016-08-21T11:15:22.000Z","updated":"2016-08-08T11:42:59.000Z","path":"About/index.html","comments":1,"layout":"page","_id":"civzfqikh0002f66obnpxzqm6","content":"<figure class=\"highlight json\"><figcaption><span>ME</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&#123; </div><div class=\"line\">  <span class=\"attr\">\"id\"</span>: <span class=\"string\">\"wo1fSea\"</span>, </div><div class=\"line\">  <span class=\"attr\">\"name\"</span>: [<span class=\"string\">\"黄铨雍\"</span>, <span class=\"string\">\"Quanyong Huang\"</span>], </div><div class=\"line\">  <span class=\"attr\">\"major\"</span>: <span class=\"string\">\"CS\"</span>,</div><div class=\"line\">  <span class=\"attr\">\"language\"</span>: [<span class=\"string\">\"潮州话\"</span>,<span class=\"string\">\"普通话\"</span>,<span class=\"string\">\"English\"</span>,<span class=\"string\">\"c/c++\"</span>],</div><div class=\"line\">  <span class=\"attr\">\"contact\"</span>: </div><div class=\"line\">    &#123; </div><div class=\"line\">      <span class=\"attr\">\"qq\"</span>: <span class=\"number\">5337338</span>, </div><div class=\"line\">      <span class=\"attr\">\"email\"</span>: <span class=\"string\">\"quanyongh@foxmail.com\"</span>, </div><div class=\"line\">      <span class=\"attr\">\"wechat\"</span>: <span class=\"string\">\"huangquanyong\"</span></div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div><div class=\"line\"></div></pre></td></tr></table></figure>\n","excerpt":"","more":"<figure class=\"highlight json\"><figcaption><span>ME</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&#123; </div><div class=\"line\">  <span class=\"attr\">\"id\"</span>: <span class=\"string\">\"wo1fSea\"</span>, </div><div class=\"line\">  <span class=\"attr\">\"name\"</span>: [<span class=\"string\">\"黄铨雍\"</span>, <span class=\"string\">\"Quanyong Huang\"</span>], </div><div class=\"line\">  <span class=\"attr\">\"major\"</span>: <span class=\"string\">\"CS\"</span>,</div><div class=\"line\">  <span class=\"attr\">\"language\"</span>: [<span class=\"string\">\"潮州话\"</span>,<span class=\"string\">\"普通话\"</span>,<span class=\"string\">\"English\"</span>,<span class=\"string\">\"c/c++\"</span>],</div><div class=\"line\">  <span class=\"attr\">\"contact\"</span>: </div><div class=\"line\">    &#123; </div><div class=\"line\">      <span class=\"attr\">\"qq\"</span>: <span class=\"number\">5337338</span>, </div><div class=\"line\">      <span class=\"attr\">\"email\"</span>: <span class=\"string\">\"quanyongh@foxmail.com\"</span>, </div><div class=\"line\">      <span class=\"attr\">\"wechat\"</span>: <span class=\"string\">\"huangquanyong\"</span></div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div><div class=\"line\"></div></pre></td></tr></table></figure>\n"}],"Post":[{"title":"实习离职","date":"2014-11-27T21:41:42.000Z","_content":"\n今天终于实习离职了，从5月8日到11月28日，在网易游戏实习了接近7个月。今天离职信里终结了下，在UniSDK，完整的东西大概做了下面这些，然后零零索索的给游戏处理各种iOS疑难杂症。\n\n\t+ NtUniSdkFramework\n\t\t+ 91\n\t\t+ PP\n\t\t+ Tongbu\n\t\t+ DownJoy\n\t\t+ iTools\n\t\t+ KuaiYong\n\t\t+ NetEase\n\t\t+ YiXin\n\t\t+ Line\n\n\t+ NtShareSdkFramework\n\t\t+ YiXin\n\t\t+ WeiXin\n\t\t+ Weibo\n\n\t+ NtUniSdk Xcode Plugin\n\n\t+ U3D C# Wrapper for both Android and iOS NtUniSdk\n\n\t+ Flash ANE for both Android and iOS NtUniSdk\n\n <!-- more -->\n\n大半年来，还是能学到不少东西，从没接触过iOS开发，到现在许多线上的项目都用着我们的iOS UniSDK。体会最深的还是，AppStore IAP部分的代码，来来去去，踩了不少坑，也加了不少班。对一个比较长的业务流程，其实是很难保证在上线前能得到非常完备的测试的。在大量的用户面前，你完全不知道用户到底会如何使用。另外，各种概率性出现的bug也是很难重现的。比如，第一次IAP的代码上线的时候，和G3程序在重现一个0。1%概率的bug，愣是一个下午过去了，都没能重现出来，最后，也是直接靠猜了。\n\n![用户是这样使用我们开发的软件的](http://ww1.sinaimg.cn/bmiddle/82a507cagw1emndj5fsn2g20dw07tnbp.gif)\n\n明天，就不用再考虑上班的事了，先睡几天大懒觉。\n今天走的时候，一个同学说，“你居然是实习，你放着大好的时间不去浪，在这里呆了7个月？你以后会后悔的。”\n可是，不实习，回来学校还是要干活的啊...\n","source":"_posts/A_New_Begin.md","raw":"title: 实习离职\ndate: 2014-11-28 05:41:42\ntags: [Game, Work]\n---\n\n今天终于实习离职了，从5月8日到11月28日，在网易游戏实习了接近7个月。今天离职信里终结了下，在UniSDK，完整的东西大概做了下面这些，然后零零索索的给游戏处理各种iOS疑难杂症。\n\n\t+ NtUniSdkFramework\n\t\t+ 91\n\t\t+ PP\n\t\t+ Tongbu\n\t\t+ DownJoy\n\t\t+ iTools\n\t\t+ KuaiYong\n\t\t+ NetEase\n\t\t+ YiXin\n\t\t+ Line\n\n\t+ NtShareSdkFramework\n\t\t+ YiXin\n\t\t+ WeiXin\n\t\t+ Weibo\n\n\t+ NtUniSdk Xcode Plugin\n\n\t+ U3D C# Wrapper for both Android and iOS NtUniSdk\n\n\t+ Flash ANE for both Android and iOS NtUniSdk\n\n <!-- more -->\n\n大半年来，还是能学到不少东西，从没接触过iOS开发，到现在许多线上的项目都用着我们的iOS UniSDK。体会最深的还是，AppStore IAP部分的代码，来来去去，踩了不少坑，也加了不少班。对一个比较长的业务流程，其实是很难保证在上线前能得到非常完备的测试的。在大量的用户面前，你完全不知道用户到底会如何使用。另外，各种概率性出现的bug也是很难重现的。比如，第一次IAP的代码上线的时候，和G3程序在重现一个0。1%概率的bug，愣是一个下午过去了，都没能重现出来，最后，也是直接靠猜了。\n\n![用户是这样使用我们开发的软件的](http://ww1.sinaimg.cn/bmiddle/82a507cagw1emndj5fsn2g20dw07tnbp.gif)\n\n明天，就不用再考虑上班的事了，先睡几天大懒觉。\n今天走的时候，一个同学说，“你居然是实习，你放着大好的时间不去浪，在这里呆了7个月？你以后会后悔的。”\n可是，不实习，回来学校还是要干活的啊...\n","slug":"A_New_Begin","published":1,"updated":"2016-11-26T16:47:27.000Z","_id":"civzfqikd0001f66otnqkgjp6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>今天终于实习离职了，从5月8日到11月28日，在网易游戏实习了接近7个月。今天离职信里终结了下，在UniSDK，完整的东西大概做了下面这些，然后零零索索的给游戏处理各种iOS疑难杂症。</p>\n<pre><code>+ NtUniSdkFramework\n    + 91\n    + PP\n    + Tongbu\n    + DownJoy\n    + iTools\n    + KuaiYong\n    + NetEase\n    + YiXin\n    + Line\n\n+ NtShareSdkFramework\n    + YiXin\n    + WeiXin\n    + Weibo\n\n+ NtUniSdk Xcode Plugin\n\n+ U3D C# Wrapper for both Android and iOS NtUniSdk\n\n+ Flash ANE for both Android and iOS NtUniSdk\n</code></pre> <a id=\"more\"></a>\n<p>大半年来，还是能学到不少东西，从没接触过iOS开发，到现在许多线上的项目都用着我们的iOS UniSDK。体会最深的还是，AppStore IAP部分的代码，来来去去，踩了不少坑，也加了不少班。对一个比较长的业务流程，其实是很难保证在上线前能得到非常完备的测试的。在大量的用户面前，你完全不知道用户到底会如何使用。另外，各种概率性出现的bug也是很难重现的。比如，第一次IAP的代码上线的时候，和G3程序在重现一个0。1%概率的bug，愣是一个下午过去了，都没能重现出来，最后，也是直接靠猜了。</p>\n<p><img src=\"http://ww1.sinaimg.cn/bmiddle/82a507cagw1emndj5fsn2g20dw07tnbp.gif\" alt=\"用户是这样使用我们开发的软件的\"></p>\n<p>明天，就不用再考虑上班的事了，先睡几天大懒觉。<br>今天走的时候，一个同学说，“你居然是实习，你放着大好的时间不去浪，在这里呆了7个月？你以后会后悔的。”<br>可是，不实习，回来学校还是要干活的啊…</p>\n","excerpt":"<p>今天终于实习离职了，从5月8日到11月28日，在网易游戏实习了接近7个月。今天离职信里终结了下，在UniSDK，完整的东西大概做了下面这些，然后零零索索的给游戏处理各种iOS疑难杂症。</p>\n<pre><code>+ NtUniSdkFramework\n    + 91\n    + PP\n    + Tongbu\n    + DownJoy\n    + iTools\n    + KuaiYong\n    + NetEase\n    + YiXin\n    + Line\n\n+ NtShareSdkFramework\n    + YiXin\n    + WeiXin\n    + Weibo\n\n+ NtUniSdk Xcode Plugin\n\n+ U3D C# Wrapper for both Android and iOS NtUniSdk\n\n+ Flash ANE for both Android and iOS NtUniSdk\n</code></pre>","more":"<p>大半年来，还是能学到不少东西，从没接触过iOS开发，到现在许多线上的项目都用着我们的iOS UniSDK。体会最深的还是，AppStore IAP部分的代码，来来去去，踩了不少坑，也加了不少班。对一个比较长的业务流程，其实是很难保证在上线前能得到非常完备的测试的。在大量的用户面前，你完全不知道用户到底会如何使用。另外，各种概率性出现的bug也是很难重现的。比如，第一次IAP的代码上线的时候，和G3程序在重现一个0。1%概率的bug，愣是一个下午过去了，都没能重现出来，最后，也是直接靠猜了。</p>\n<p><img src=\"http://ww1.sinaimg.cn/bmiddle/82a507cagw1emndj5fsn2g20dw07tnbp.gif\" alt=\"用户是这样使用我们开发的软件的\"></p>\n<p>明天，就不用再考虑上班的事了，先睡几天大懒觉。<br>今天走的时候，一个同学说，“你居然是实习，你放着大好的时间不去浪，在这里呆了7个月？你以后会后悔的。”<br>可是，不实习，回来学校还是要干活的啊…</p>"},{"title":"A_New_Blog","date":"2014-07-17T00:25:34.000Z","_content":"\n折腾了几天，先post上第一篇。\n","source":"_posts/A_New_Blog.md","raw":"title: A_New_Blog\ndate: 2014-07-17 08:25:34\ntags: daily\n---\n\n折腾了几天，先post上第一篇。\n","slug":"A_New_Blog","published":1,"updated":"2016-11-26T16:46:49.000Z","_id":"civzfqikm0003f66ovj6ayvp0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>折腾了几天，先post上第一篇。</p>\n","excerpt":"","more":"<p>折腾了几天，先post上第一篇。</p>\n"},{"title":"谷阿莫带你十分钟看完 NavMesh 生成算法","date":"2016-08-21T04:32:22.000Z","_content":"\n*（本文配图皆来自《Crowds In A Polygon Soup: Next-Gen Path Planning》By David Miles, David Miles, David Miles, David Miles 与 《Study: Navigation Mesh Generation》By Stephen Pratt。“窃书不能算偷……窃书！……读书人的事，能算偷么？”）*\n\n大家好，我是谷阿莫，今天我给大家带来的是 NavMesh 的生成方法。\n\n这个算法从一个二维的简化例子开始讲起。当我们谈寻路算法的时候，在二维世界中，我们谈的是这样一个问题：\n\n如下图，左边有个走廊，中间是一个通道，右边是一个骷髅状的洞穴。起点在左，目标在右，如何找到一条最为合适的路径。\n\n在这个例子中，我们似乎很难直接求解一个合适的路径。主要的问题时，我们掌握的数据并不是一个抽象的结构化的数据。\n\n所以，首先，我们需要从问题中产生一个抽象的结构化的数据，用来简化问题求解。\n\n![A Navigation Case in 2D](/images/About_NavMesh/Image[1].png)\n\n<!-- more --> \n\n一个很朴素的思路，即是把地图数据栅格化（像素化）。在栅格化的地图上，至少可以通过搜索格子的方式（向周围四方向搜索或八方向）找到一条可行的路径，尽管很挫。\n\n![Pixelize Voxelize](/images/About_NavMesh/Image[2].png)\n\n在栅格化的地图上做一个边缘提取，获得地图区域像素化后的内边缘，得到以下图形数据。\n\n![Extract Edge](/images/About_NavMesh/Image[3].png)\n\n进一步，对锯齿化的边缘进行简化，得到一个简化的多边形地图区域。\n\n![Simplify Polygon](/images/About_NavMesh/Image[4].png)\n\n可以使用下述方法对锯齿化的边缘进行简化。\n选择两个点进行连线可得到一条简化的边。\n\n![Simplify Polygon](/images/About_NavMesh/Image[5].png)\n\n找到离该简化边缘距离最远的点，将该点加入简化多变形的轮廓集合中，此时将产生替代旧边缘的两条新的简化边缘。\n\n![Simplify Polygon](/images/About_NavMesh/Image[6].png)\n\n重复该过程，直到所有不在简化轮廓集合中的点距离简化的边缘距离都小于某阈值。\n\n![Simplify Polygon](/images/About_NavMesh/Image[7].png)\n\n考虑到简化后的地图实际上很多存在很多可以直接通过直线联通的区域，我们可以进一步对这个地图做一个简单的划分。如下图，简化后的多边形地图区域可以分割为以下四个联通区域。\n  \n![Partition Into Convex Areas](/images/About_NavMesh/Image[8].png)\n\n分割区域按照以下算法进行：\n两点间直线距离/两点边界距离 为 度量，当该值小于一定阈值时，进行区域分割。\n\n![Convex Partitioning](/images/About_NavMesh/Image[9].png)\n\n该过程可以以递归的方式进行，整个过程复杂度<=O(Log(n)*n)，n为地图边。\n\n![Recursively Partition](/images/About_NavMesh/Image[10].png)\n\n在完成区域分割后，我们可将整个地图数据视为一个图。即 左走廊 -> 中间通道 -> 右上洞穴区域 -> 右下洞穴区域。每个图节点区域中的两点都可以通过简单的直线路径相互连通。\n\n![Convex Area Graph Complete](/images/About_NavMesh/Image[11].png)\n\n此时，我们可以用最短路径算法（如 Dijkstra ）来解决图节点间的寻路问题，而图节点内的路径可以简单的通过两点间连线完成。\n\n![Pathfinding](/images/About_NavMesh/Image[12].png)\n\n上面例子是一个最简单的地图形式，下面考虑地图中带空洞（不可行走）区域的情况。下图在右边骷髅状洞穴区域添加两个不可行走的空洞。我们希望算法能够生成如下图表示的寻路路径。\n\n![Holes in the Free-Space](/images/About_NavMesh/Image[13].png)\n\n使用和上文描述相同的步骤对地图进行像素画、边缘提取、多边形简化，可以得到如下地图数据。对每个空洞区域， 找到其和地图边界点距离最小的点，将该两点的连线作为额外边界添加到地图中。\n\n![Splice Location](/images/About_NavMesh/Image[14].png)\n\n此时，地图退化为简单多边形（如下图所示），应用上述区域分割方法即可将地图进一步处理。\n\n![Add Splice Segments](/images/About_NavMesh/Image[15].png)\n\n将地图抽象为如下联通区域图，即可在图上应用寻路算法。\n\n![Convex Area Graph Complete](/images/About_NavMesh/Image[16].png)\n\n看一个三维空间上的例子，在3维空间中，我们需要将二维对地图数据的像素化过程变为对三维地图模型数据的体素化过程。\n\n![Case in 3D](/images/About_NavMesh/Image[17].png)\n\n而事实上，在三维空间，模型数据表示的是不可进入的区域，在空间中，可以使用下图数据结构表示可行走的地图区域，每一个二维地图网格中存储一组由可行走区域上边界与下边界描述的数据。其中，可行走区域的下边界，即地板表面数据即是我们用来生成寻路网格的表面。\n\n![Open Spans](/images/About_NavMesh/Image[18].png)\n\n如下图所示，使用寻路角色身高可以对可行走区域进行剔除。\n\n![Walkable Surface Removal](/images/About_NavMesh/Image[19].png)\n\n考虑一个在三维空间中可行区域存在重叠的情况（如下图，形如一个盘旋的楼梯区域）。\n\n![3D Overlap](/images/About_NavMesh/Image[20].png)\n\n直接使用和上文二维例子描述中相同的区域分割算法进行区域分割。\n\n![3D Partitioning](/images/About_NavMesh/Image[21].png)\n\n上图所示地图可被分割为如下所示无重叠的两部分区域，即三维空间中地图重叠部分可在区域分割过程中解决。可对该两区域继续递归进行处理，生成上文描述的寻路区域数据。\n\n![3D Partitioning](/images/About_NavMesh/Image[22].png)\n\n对于不同体型半径的，我们希望会生成不同的寻路路径，如下图例子所示，寻路角色体型半径过大无法通过中间连接区域，所以图中在上文生成的路径对体型半径过大的角色是不可行的。\n\n![Different Creature Shapes](/images/About_NavMesh/Image[23].png)\n\n该问题可以在提取地图区域边缘时，向内多取一个角色体型半径生成特殊的寻路地图（即每种半径生成一个寻路网格）。同一地图数据，针对大体型角色，边缘提取过程后生成的寻路区域如下图所示。\n\n![Different Creature Shapes](/images/About_NavMesh/Image[24].png)\n\n关于动态障碍，可采用在运行时改变寻路地图与动态障碍物重叠的节点数据完成，如下图所示，再添加动态障碍物前期望生成的寻路路径如左图，添加障碍物后期望生成的寻路路径如右图。\n\n![Dynamic Obstacles](/images/About_NavMesh/Image[25].png)\n\n添加动态障碍物后，仅需在运行时替换与障碍物重叠的BCD节点，将其数据替换为B1B2C1C2D1D2D3节点，当障碍从地图中取出后再将界点恢复。\n\n![Dynamic Obstacles](/images/About_NavMesh/Image[26].png)\n\n关于如何寻找寻路路径上的拐点。当路径跨多个联通区域时，可使用以下方法确定路径上的拐点。\n\n![Finding the Next Corner](/images/About_NavMesh/Image[27].png)\n\n首先，确定路径上穿过的区域边缘。\n\n![“Portals” Between Areas](/images/About_NavMesh/Image[28].png)\n\n顺序遍历边缘，记录最右的左边缘点与最左的右边缘点。\n\n![Finding the Next Corner](/images/About_NavMesh/Image[29].png)\n![Finding the Next Corner](/images/About_NavMesh/Image[30].png)\n\n当最右的左边缘点与最右的左边缘点发生重叠时，此时该两边缘点中较早遇到的即是路径上的拐点。将起始位置置为该拐点，继续进行相同处理，直至找到路径上所有拐点。\n\n![Finding the Next Corner](/images/About_NavMesh/Image[31].png)\n\n这里就结束了，科科。\n","source":"_posts/A_Quick_Introduction_to_NavMesh.md","raw":"title: 谷阿莫带你十分钟看完 NavMesh 生成算法\ndate: 2016-08-21 12:32:22\ntags: [Recast & Detour,NavMesh,Game]\n---\n\n*（本文配图皆来自《Crowds In A Polygon Soup: Next-Gen Path Planning》By David Miles, David Miles, David Miles, David Miles 与 《Study: Navigation Mesh Generation》By Stephen Pratt。“窃书不能算偷……窃书！……读书人的事，能算偷么？”）*\n\n大家好，我是谷阿莫，今天我给大家带来的是 NavMesh 的生成方法。\n\n这个算法从一个二维的简化例子开始讲起。当我们谈寻路算法的时候，在二维世界中，我们谈的是这样一个问题：\n\n如下图，左边有个走廊，中间是一个通道，右边是一个骷髅状的洞穴。起点在左，目标在右，如何找到一条最为合适的路径。\n\n在这个例子中，我们似乎很难直接求解一个合适的路径。主要的问题时，我们掌握的数据并不是一个抽象的结构化的数据。\n\n所以，首先，我们需要从问题中产生一个抽象的结构化的数据，用来简化问题求解。\n\n![A Navigation Case in 2D](/images/About_NavMesh/Image[1].png)\n\n<!-- more --> \n\n一个很朴素的思路，即是把地图数据栅格化（像素化）。在栅格化的地图上，至少可以通过搜索格子的方式（向周围四方向搜索或八方向）找到一条可行的路径，尽管很挫。\n\n![Pixelize Voxelize](/images/About_NavMesh/Image[2].png)\n\n在栅格化的地图上做一个边缘提取，获得地图区域像素化后的内边缘，得到以下图形数据。\n\n![Extract Edge](/images/About_NavMesh/Image[3].png)\n\n进一步，对锯齿化的边缘进行简化，得到一个简化的多边形地图区域。\n\n![Simplify Polygon](/images/About_NavMesh/Image[4].png)\n\n可以使用下述方法对锯齿化的边缘进行简化。\n选择两个点进行连线可得到一条简化的边。\n\n![Simplify Polygon](/images/About_NavMesh/Image[5].png)\n\n找到离该简化边缘距离最远的点，将该点加入简化多变形的轮廓集合中，此时将产生替代旧边缘的两条新的简化边缘。\n\n![Simplify Polygon](/images/About_NavMesh/Image[6].png)\n\n重复该过程，直到所有不在简化轮廓集合中的点距离简化的边缘距离都小于某阈值。\n\n![Simplify Polygon](/images/About_NavMesh/Image[7].png)\n\n考虑到简化后的地图实际上很多存在很多可以直接通过直线联通的区域，我们可以进一步对这个地图做一个简单的划分。如下图，简化后的多边形地图区域可以分割为以下四个联通区域。\n  \n![Partition Into Convex Areas](/images/About_NavMesh/Image[8].png)\n\n分割区域按照以下算法进行：\n两点间直线距离/两点边界距离 为 度量，当该值小于一定阈值时，进行区域分割。\n\n![Convex Partitioning](/images/About_NavMesh/Image[9].png)\n\n该过程可以以递归的方式进行，整个过程复杂度<=O(Log(n)*n)，n为地图边。\n\n![Recursively Partition](/images/About_NavMesh/Image[10].png)\n\n在完成区域分割后，我们可将整个地图数据视为一个图。即 左走廊 -> 中间通道 -> 右上洞穴区域 -> 右下洞穴区域。每个图节点区域中的两点都可以通过简单的直线路径相互连通。\n\n![Convex Area Graph Complete](/images/About_NavMesh/Image[11].png)\n\n此时，我们可以用最短路径算法（如 Dijkstra ）来解决图节点间的寻路问题，而图节点内的路径可以简单的通过两点间连线完成。\n\n![Pathfinding](/images/About_NavMesh/Image[12].png)\n\n上面例子是一个最简单的地图形式，下面考虑地图中带空洞（不可行走）区域的情况。下图在右边骷髅状洞穴区域添加两个不可行走的空洞。我们希望算法能够生成如下图表示的寻路路径。\n\n![Holes in the Free-Space](/images/About_NavMesh/Image[13].png)\n\n使用和上文描述相同的步骤对地图进行像素画、边缘提取、多边形简化，可以得到如下地图数据。对每个空洞区域， 找到其和地图边界点距离最小的点，将该两点的连线作为额外边界添加到地图中。\n\n![Splice Location](/images/About_NavMesh/Image[14].png)\n\n此时，地图退化为简单多边形（如下图所示），应用上述区域分割方法即可将地图进一步处理。\n\n![Add Splice Segments](/images/About_NavMesh/Image[15].png)\n\n将地图抽象为如下联通区域图，即可在图上应用寻路算法。\n\n![Convex Area Graph Complete](/images/About_NavMesh/Image[16].png)\n\n看一个三维空间上的例子，在3维空间中，我们需要将二维对地图数据的像素化过程变为对三维地图模型数据的体素化过程。\n\n![Case in 3D](/images/About_NavMesh/Image[17].png)\n\n而事实上，在三维空间，模型数据表示的是不可进入的区域，在空间中，可以使用下图数据结构表示可行走的地图区域，每一个二维地图网格中存储一组由可行走区域上边界与下边界描述的数据。其中，可行走区域的下边界，即地板表面数据即是我们用来生成寻路网格的表面。\n\n![Open Spans](/images/About_NavMesh/Image[18].png)\n\n如下图所示，使用寻路角色身高可以对可行走区域进行剔除。\n\n![Walkable Surface Removal](/images/About_NavMesh/Image[19].png)\n\n考虑一个在三维空间中可行区域存在重叠的情况（如下图，形如一个盘旋的楼梯区域）。\n\n![3D Overlap](/images/About_NavMesh/Image[20].png)\n\n直接使用和上文二维例子描述中相同的区域分割算法进行区域分割。\n\n![3D Partitioning](/images/About_NavMesh/Image[21].png)\n\n上图所示地图可被分割为如下所示无重叠的两部分区域，即三维空间中地图重叠部分可在区域分割过程中解决。可对该两区域继续递归进行处理，生成上文描述的寻路区域数据。\n\n![3D Partitioning](/images/About_NavMesh/Image[22].png)\n\n对于不同体型半径的，我们希望会生成不同的寻路路径，如下图例子所示，寻路角色体型半径过大无法通过中间连接区域，所以图中在上文生成的路径对体型半径过大的角色是不可行的。\n\n![Different Creature Shapes](/images/About_NavMesh/Image[23].png)\n\n该问题可以在提取地图区域边缘时，向内多取一个角色体型半径生成特殊的寻路地图（即每种半径生成一个寻路网格）。同一地图数据，针对大体型角色，边缘提取过程后生成的寻路区域如下图所示。\n\n![Different Creature Shapes](/images/About_NavMesh/Image[24].png)\n\n关于动态障碍，可采用在运行时改变寻路地图与动态障碍物重叠的节点数据完成，如下图所示，再添加动态障碍物前期望生成的寻路路径如左图，添加障碍物后期望生成的寻路路径如右图。\n\n![Dynamic Obstacles](/images/About_NavMesh/Image[25].png)\n\n添加动态障碍物后，仅需在运行时替换与障碍物重叠的BCD节点，将其数据替换为B1B2C1C2D1D2D3节点，当障碍从地图中取出后再将界点恢复。\n\n![Dynamic Obstacles](/images/About_NavMesh/Image[26].png)\n\n关于如何寻找寻路路径上的拐点。当路径跨多个联通区域时，可使用以下方法确定路径上的拐点。\n\n![Finding the Next Corner](/images/About_NavMesh/Image[27].png)\n\n首先，确定路径上穿过的区域边缘。\n\n![“Portals” Between Areas](/images/About_NavMesh/Image[28].png)\n\n顺序遍历边缘，记录最右的左边缘点与最左的右边缘点。\n\n![Finding the Next Corner](/images/About_NavMesh/Image[29].png)\n![Finding the Next Corner](/images/About_NavMesh/Image[30].png)\n\n当最右的左边缘点与最右的左边缘点发生重叠时，此时该两边缘点中较早遇到的即是路径上的拐点。将起始位置置为该拐点，继续进行相同处理，直至找到路径上所有拐点。\n\n![Finding the Next Corner](/images/About_NavMesh/Image[31].png)\n\n这里就结束了，科科。\n","slug":"A_Quick_Introduction_to_NavMesh","published":1,"updated":"2016-10-01T17:24:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civzfqiku0005f66od8dn4kkm","content":"<p><em>（本文配图皆来自《Crowds In A Polygon Soup: Next-Gen Path Planning》By David Miles, David Miles, David Miles, David Miles 与 《Study: Navigation Mesh Generation》By Stephen Pratt。“窃书不能算偷……窃书！……读书人的事，能算偷么？”）</em></p>\n<p>大家好，我是谷阿莫，今天我给大家带来的是 NavMesh 的生成方法。</p>\n<p>这个算法从一个二维的简化例子开始讲起。当我们谈寻路算法的时候，在二维世界中，我们谈的是这样一个问题：</p>\n<p>如下图，左边有个走廊，中间是一个通道，右边是一个骷髅状的洞穴。起点在左，目标在右，如何找到一条最为合适的路径。</p>\n<p>在这个例子中，我们似乎很难直接求解一个合适的路径。主要的问题时，我们掌握的数据并不是一个抽象的结构化的数据。</p>\n<p>所以，首先，我们需要从问题中产生一个抽象的结构化的数据，用来简化问题求解。</p>\n<p><img src=\"/images/About_NavMesh/Image[1].png\" alt=\"A Navigation Case in 2D\"></p>\n<a id=\"more\"></a> \n<p>一个很朴素的思路，即是把地图数据栅格化（像素化）。在栅格化的地图上，至少可以通过搜索格子的方式（向周围四方向搜索或八方向）找到一条可行的路径，尽管很挫。</p>\n<p><img src=\"/images/About_NavMesh/Image[2].png\" alt=\"Pixelize Voxelize\"></p>\n<p>在栅格化的地图上做一个边缘提取，获得地图区域像素化后的内边缘，得到以下图形数据。</p>\n<p><img src=\"/images/About_NavMesh/Image[3].png\" alt=\"Extract Edge\"></p>\n<p>进一步，对锯齿化的边缘进行简化，得到一个简化的多边形地图区域。</p>\n<p><img src=\"/images/About_NavMesh/Image[4].png\" alt=\"Simplify Polygon\"></p>\n<p>可以使用下述方法对锯齿化的边缘进行简化。<br>选择两个点进行连线可得到一条简化的边。</p>\n<p><img src=\"/images/About_NavMesh/Image[5].png\" alt=\"Simplify Polygon\"></p>\n<p>找到离该简化边缘距离最远的点，将该点加入简化多变形的轮廓集合中，此时将产生替代旧边缘的两条新的简化边缘。</p>\n<p><img src=\"/images/About_NavMesh/Image[6].png\" alt=\"Simplify Polygon\"></p>\n<p>重复该过程，直到所有不在简化轮廓集合中的点距离简化的边缘距离都小于某阈值。</p>\n<p><img src=\"/images/About_NavMesh/Image[7].png\" alt=\"Simplify Polygon\"></p>\n<p>考虑到简化后的地图实际上很多存在很多可以直接通过直线联通的区域，我们可以进一步对这个地图做一个简单的划分。如下图，简化后的多边形地图区域可以分割为以下四个联通区域。</p>\n<p><img src=\"/images/About_NavMesh/Image[8].png\" alt=\"Partition Into Convex Areas\"></p>\n<p>分割区域按照以下算法进行：<br>两点间直线距离/两点边界距离 为 度量，当该值小于一定阈值时，进行区域分割。</p>\n<p><img src=\"/images/About_NavMesh/Image[9].png\" alt=\"Convex Partitioning\"></p>\n<p>该过程可以以递归的方式进行，整个过程复杂度&lt;=O(Log(n)*n)，n为地图边。</p>\n<p><img src=\"/images/About_NavMesh/Image[10].png\" alt=\"Recursively Partition\"></p>\n<p>在完成区域分割后，我们可将整个地图数据视为一个图。即 左走廊 -&gt; 中间通道 -&gt; 右上洞穴区域 -&gt; 右下洞穴区域。每个图节点区域中的两点都可以通过简单的直线路径相互连通。</p>\n<p><img src=\"/images/About_NavMesh/Image[11].png\" alt=\"Convex Area Graph Complete\"></p>\n<p>此时，我们可以用最短路径算法（如 Dijkstra ）来解决图节点间的寻路问题，而图节点内的路径可以简单的通过两点间连线完成。</p>\n<p><img src=\"/images/About_NavMesh/Image[12].png\" alt=\"Pathfinding\"></p>\n<p>上面例子是一个最简单的地图形式，下面考虑地图中带空洞（不可行走）区域的情况。下图在右边骷髅状洞穴区域添加两个不可行走的空洞。我们希望算法能够生成如下图表示的寻路路径。</p>\n<p><img src=\"/images/About_NavMesh/Image[13].png\" alt=\"Holes in the Free-Space\"></p>\n<p>使用和上文描述相同的步骤对地图进行像素画、边缘提取、多边形简化，可以得到如下地图数据。对每个空洞区域， 找到其和地图边界点距离最小的点，将该两点的连线作为额外边界添加到地图中。</p>\n<p><img src=\"/images/About_NavMesh/Image[14].png\" alt=\"Splice Location\"></p>\n<p>此时，地图退化为简单多边形（如下图所示），应用上述区域分割方法即可将地图进一步处理。</p>\n<p><img src=\"/images/About_NavMesh/Image[15].png\" alt=\"Add Splice Segments\"></p>\n<p>将地图抽象为如下联通区域图，即可在图上应用寻路算法。</p>\n<p><img src=\"/images/About_NavMesh/Image[16].png\" alt=\"Convex Area Graph Complete\"></p>\n<p>看一个三维空间上的例子，在3维空间中，我们需要将二维对地图数据的像素化过程变为对三维地图模型数据的体素化过程。</p>\n<p><img src=\"/images/About_NavMesh/Image[17].png\" alt=\"Case in 3D\"></p>\n<p>而事实上，在三维空间，模型数据表示的是不可进入的区域，在空间中，可以使用下图数据结构表示可行走的地图区域，每一个二维地图网格中存储一组由可行走区域上边界与下边界描述的数据。其中，可行走区域的下边界，即地板表面数据即是我们用来生成寻路网格的表面。</p>\n<p><img src=\"/images/About_NavMesh/Image[18].png\" alt=\"Open Spans\"></p>\n<p>如下图所示，使用寻路角色身高可以对可行走区域进行剔除。</p>\n<p><img src=\"/images/About_NavMesh/Image[19].png\" alt=\"Walkable Surface Removal\"></p>\n<p>考虑一个在三维空间中可行区域存在重叠的情况（如下图，形如一个盘旋的楼梯区域）。</p>\n<p><img src=\"/images/About_NavMesh/Image[20].png\" alt=\"3D Overlap\"></p>\n<p>直接使用和上文二维例子描述中相同的区域分割算法进行区域分割。</p>\n<p><img src=\"/images/About_NavMesh/Image[21].png\" alt=\"3D Partitioning\"></p>\n<p>上图所示地图可被分割为如下所示无重叠的两部分区域，即三维空间中地图重叠部分可在区域分割过程中解决。可对该两区域继续递归进行处理，生成上文描述的寻路区域数据。</p>\n<p><img src=\"/images/About_NavMesh/Image[22].png\" alt=\"3D Partitioning\"></p>\n<p>对于不同体型半径的，我们希望会生成不同的寻路路径，如下图例子所示，寻路角色体型半径过大无法通过中间连接区域，所以图中在上文生成的路径对体型半径过大的角色是不可行的。</p>\n<p><img src=\"/images/About_NavMesh/Image[23].png\" alt=\"Different Creature Shapes\"></p>\n<p>该问题可以在提取地图区域边缘时，向内多取一个角色体型半径生成特殊的寻路地图（即每种半径生成一个寻路网格）。同一地图数据，针对大体型角色，边缘提取过程后生成的寻路区域如下图所示。</p>\n<p><img src=\"/images/About_NavMesh/Image[24].png\" alt=\"Different Creature Shapes\"></p>\n<p>关于动态障碍，可采用在运行时改变寻路地图与动态障碍物重叠的节点数据完成，如下图所示，再添加动态障碍物前期望生成的寻路路径如左图，添加障碍物后期望生成的寻路路径如右图。</p>\n<p><img src=\"/images/About_NavMesh/Image[25].png\" alt=\"Dynamic Obstacles\"></p>\n<p>添加动态障碍物后，仅需在运行时替换与障碍物重叠的BCD节点，将其数据替换为B1B2C1C2D1D2D3节点，当障碍从地图中取出后再将界点恢复。</p>\n<p><img src=\"/images/About_NavMesh/Image[26].png\" alt=\"Dynamic Obstacles\"></p>\n<p>关于如何寻找寻路路径上的拐点。当路径跨多个联通区域时，可使用以下方法确定路径上的拐点。</p>\n<p><img src=\"/images/About_NavMesh/Image[27].png\" alt=\"Finding the Next Corner\"></p>\n<p>首先，确定路径上穿过的区域边缘。</p>\n<p><img src=\"/images/About_NavMesh/Image[28].png\" alt=\"“Portals” Between Areas\"></p>\n<p>顺序遍历边缘，记录最右的左边缘点与最左的右边缘点。</p>\n<p><img src=\"/images/About_NavMesh/Image[29].png\" alt=\"Finding the Next Corner\"><br><img src=\"/images/About_NavMesh/Image[30].png\" alt=\"Finding the Next Corner\"></p>\n<p>当最右的左边缘点与最右的左边缘点发生重叠时，此时该两边缘点中较早遇到的即是路径上的拐点。将起始位置置为该拐点，继续进行相同处理，直至找到路径上所有拐点。</p>\n<p><img src=\"/images/About_NavMesh/Image[31].png\" alt=\"Finding the Next Corner\"></p>\n<p>这里就结束了，科科。</p>\n","excerpt":"<p><em>（本文配图皆来自《Crowds In A Polygon Soup: Next-Gen Path Planning》By David Miles, David Miles, David Miles, David Miles 与 《Study: Navigation Mesh Generation》By Stephen Pratt。“窃书不能算偷……窃书！……读书人的事，能算偷么？”）</em></p>\n<p>大家好，我是谷阿莫，今天我给大家带来的是 NavMesh 的生成方法。</p>\n<p>这个算法从一个二维的简化例子开始讲起。当我们谈寻路算法的时候，在二维世界中，我们谈的是这样一个问题：</p>\n<p>如下图，左边有个走廊，中间是一个通道，右边是一个骷髅状的洞穴。起点在左，目标在右，如何找到一条最为合适的路径。</p>\n<p>在这个例子中，我们似乎很难直接求解一个合适的路径。主要的问题时，我们掌握的数据并不是一个抽象的结构化的数据。</p>\n<p>所以，首先，我们需要从问题中产生一个抽象的结构化的数据，用来简化问题求解。</p>\n<p><img src=\"/images/About_NavMesh/Image[1].png\" alt=\"A Navigation Case in 2D\"></p>","more":"<p>一个很朴素的思路，即是把地图数据栅格化（像素化）。在栅格化的地图上，至少可以通过搜索格子的方式（向周围四方向搜索或八方向）找到一条可行的路径，尽管很挫。</p>\n<p><img src=\"/images/About_NavMesh/Image[2].png\" alt=\"Pixelize Voxelize\"></p>\n<p>在栅格化的地图上做一个边缘提取，获得地图区域像素化后的内边缘，得到以下图形数据。</p>\n<p><img src=\"/images/About_NavMesh/Image[3].png\" alt=\"Extract Edge\"></p>\n<p>进一步，对锯齿化的边缘进行简化，得到一个简化的多边形地图区域。</p>\n<p><img src=\"/images/About_NavMesh/Image[4].png\" alt=\"Simplify Polygon\"></p>\n<p>可以使用下述方法对锯齿化的边缘进行简化。<br>选择两个点进行连线可得到一条简化的边。</p>\n<p><img src=\"/images/About_NavMesh/Image[5].png\" alt=\"Simplify Polygon\"></p>\n<p>找到离该简化边缘距离最远的点，将该点加入简化多变形的轮廓集合中，此时将产生替代旧边缘的两条新的简化边缘。</p>\n<p><img src=\"/images/About_NavMesh/Image[6].png\" alt=\"Simplify Polygon\"></p>\n<p>重复该过程，直到所有不在简化轮廓集合中的点距离简化的边缘距离都小于某阈值。</p>\n<p><img src=\"/images/About_NavMesh/Image[7].png\" alt=\"Simplify Polygon\"></p>\n<p>考虑到简化后的地图实际上很多存在很多可以直接通过直线联通的区域，我们可以进一步对这个地图做一个简单的划分。如下图，简化后的多边形地图区域可以分割为以下四个联通区域。</p>\n<p><img src=\"/images/About_NavMesh/Image[8].png\" alt=\"Partition Into Convex Areas\"></p>\n<p>分割区域按照以下算法进行：<br>两点间直线距离/两点边界距离 为 度量，当该值小于一定阈值时，进行区域分割。</p>\n<p><img src=\"/images/About_NavMesh/Image[9].png\" alt=\"Convex Partitioning\"></p>\n<p>该过程可以以递归的方式进行，整个过程复杂度&lt;=O(Log(n)*n)，n为地图边。</p>\n<p><img src=\"/images/About_NavMesh/Image[10].png\" alt=\"Recursively Partition\"></p>\n<p>在完成区域分割后，我们可将整个地图数据视为一个图。即 左走廊 -&gt; 中间通道 -&gt; 右上洞穴区域 -&gt; 右下洞穴区域。每个图节点区域中的两点都可以通过简单的直线路径相互连通。</p>\n<p><img src=\"/images/About_NavMesh/Image[11].png\" alt=\"Convex Area Graph Complete\"></p>\n<p>此时，我们可以用最短路径算法（如 Dijkstra ）来解决图节点间的寻路问题，而图节点内的路径可以简单的通过两点间连线完成。</p>\n<p><img src=\"/images/About_NavMesh/Image[12].png\" alt=\"Pathfinding\"></p>\n<p>上面例子是一个最简单的地图形式，下面考虑地图中带空洞（不可行走）区域的情况。下图在右边骷髅状洞穴区域添加两个不可行走的空洞。我们希望算法能够生成如下图表示的寻路路径。</p>\n<p><img src=\"/images/About_NavMesh/Image[13].png\" alt=\"Holes in the Free-Space\"></p>\n<p>使用和上文描述相同的步骤对地图进行像素画、边缘提取、多边形简化，可以得到如下地图数据。对每个空洞区域， 找到其和地图边界点距离最小的点，将该两点的连线作为额外边界添加到地图中。</p>\n<p><img src=\"/images/About_NavMesh/Image[14].png\" alt=\"Splice Location\"></p>\n<p>此时，地图退化为简单多边形（如下图所示），应用上述区域分割方法即可将地图进一步处理。</p>\n<p><img src=\"/images/About_NavMesh/Image[15].png\" alt=\"Add Splice Segments\"></p>\n<p>将地图抽象为如下联通区域图，即可在图上应用寻路算法。</p>\n<p><img src=\"/images/About_NavMesh/Image[16].png\" alt=\"Convex Area Graph Complete\"></p>\n<p>看一个三维空间上的例子，在3维空间中，我们需要将二维对地图数据的像素化过程变为对三维地图模型数据的体素化过程。</p>\n<p><img src=\"/images/About_NavMesh/Image[17].png\" alt=\"Case in 3D\"></p>\n<p>而事实上，在三维空间，模型数据表示的是不可进入的区域，在空间中，可以使用下图数据结构表示可行走的地图区域，每一个二维地图网格中存储一组由可行走区域上边界与下边界描述的数据。其中，可行走区域的下边界，即地板表面数据即是我们用来生成寻路网格的表面。</p>\n<p><img src=\"/images/About_NavMesh/Image[18].png\" alt=\"Open Spans\"></p>\n<p>如下图所示，使用寻路角色身高可以对可行走区域进行剔除。</p>\n<p><img src=\"/images/About_NavMesh/Image[19].png\" alt=\"Walkable Surface Removal\"></p>\n<p>考虑一个在三维空间中可行区域存在重叠的情况（如下图，形如一个盘旋的楼梯区域）。</p>\n<p><img src=\"/images/About_NavMesh/Image[20].png\" alt=\"3D Overlap\"></p>\n<p>直接使用和上文二维例子描述中相同的区域分割算法进行区域分割。</p>\n<p><img src=\"/images/About_NavMesh/Image[21].png\" alt=\"3D Partitioning\"></p>\n<p>上图所示地图可被分割为如下所示无重叠的两部分区域，即三维空间中地图重叠部分可在区域分割过程中解决。可对该两区域继续递归进行处理，生成上文描述的寻路区域数据。</p>\n<p><img src=\"/images/About_NavMesh/Image[22].png\" alt=\"3D Partitioning\"></p>\n<p>对于不同体型半径的，我们希望会生成不同的寻路路径，如下图例子所示，寻路角色体型半径过大无法通过中间连接区域，所以图中在上文生成的路径对体型半径过大的角色是不可行的。</p>\n<p><img src=\"/images/About_NavMesh/Image[23].png\" alt=\"Different Creature Shapes\"></p>\n<p>该问题可以在提取地图区域边缘时，向内多取一个角色体型半径生成特殊的寻路地图（即每种半径生成一个寻路网格）。同一地图数据，针对大体型角色，边缘提取过程后生成的寻路区域如下图所示。</p>\n<p><img src=\"/images/About_NavMesh/Image[24].png\" alt=\"Different Creature Shapes\"></p>\n<p>关于动态障碍，可采用在运行时改变寻路地图与动态障碍物重叠的节点数据完成，如下图所示，再添加动态障碍物前期望生成的寻路路径如左图，添加障碍物后期望生成的寻路路径如右图。</p>\n<p><img src=\"/images/About_NavMesh/Image[25].png\" alt=\"Dynamic Obstacles\"></p>\n<p>添加动态障碍物后，仅需在运行时替换与障碍物重叠的BCD节点，将其数据替换为B1B2C1C2D1D2D3节点，当障碍从地图中取出后再将界点恢复。</p>\n<p><img src=\"/images/About_NavMesh/Image[26].png\" alt=\"Dynamic Obstacles\"></p>\n<p>关于如何寻找寻路路径上的拐点。当路径跨多个联通区域时，可使用以下方法确定路径上的拐点。</p>\n<p><img src=\"/images/About_NavMesh/Image[27].png\" alt=\"Finding the Next Corner\"></p>\n<p>首先，确定路径上穿过的区域边缘。</p>\n<p><img src=\"/images/About_NavMesh/Image[28].png\" alt=\"“Portals” Between Areas\"></p>\n<p>顺序遍历边缘，记录最右的左边缘点与最左的右边缘点。</p>\n<p><img src=\"/images/About_NavMesh/Image[29].png\" alt=\"Finding the Next Corner\"><br><img src=\"/images/About_NavMesh/Image[30].png\" alt=\"Finding the Next Corner\"></p>\n<p>当最右的左边缘点与最右的左边缘点发生重叠时，此时该两边缘点中较早遇到的即是路径上的拐点。将起始位置置为该拐点，继续进行相同处理，直至找到路径上所有拐点。</p>\n<p><img src=\"/images/About_NavMesh/Image[31].png\" alt=\"Finding the Next Corner\"></p>\n<p>这里就结束了，科科。</p>"},{"title":"关于AppStore IAP的新旧Receipt","date":"2014-08-17T13:27:40.000Z","_content":"\niOS7.0后，SKPayment的property transactionReceipt变成了DEPRECATED。\n\n建议使用新接口来实现receipt的获取。\n\n\t [[[NSBundle mainBundle] appStoreReceiptURL] dataWithContentsOfURL:receiptURL];\n\n如果使用了IAP，Apple官方的建议是使用下列代码来处理：\n\n    NSData *receipt = nil;\n    \n    if (floor(NSFoundationVersionNumber) <= NSFoundationVersionNumber_iOS_6_1) {\n        // Load resources for iOS 6.1 or earlier\n        receipt = transaction.transactionReceipt;\n        \n    } else {\n        NSURL *receiptURL = [[NSBundle mainBundle] appStoreReceiptURL];\n        receipt = [NSData dataWithContentsOfURL:receiptURL];\n    }\n\n上面的代码很容易以为，新旧接口取得的receipt格式是一致的。其实不然。\n\n <!-- more --> \n\n在NtUniSdk里面,iOS官方渠道的易信和网易通行证使用了IAP,然后使用了上述Apple官方建议的代码，结果就是receipt格式不一致，计费验证不通过，把接入SDK的G3坑了一顿。\n\n原来旧接口返回的receipt如下：\n\n\t2014-07-24 15:53:51.284 [NetEase]iOSNtUniSdkFrameworkDemo[22831:4107] [NtUniSdk] IAP jsonResponse: {\n    \treceipt =     {\n        \tbid = \"com.netease.sdk.test\";\n        \tbvrs = \"1.0\";\n        \t\"item_id\" = 892617314;\n        \t\"original_purchase_date\" = \"2014-07-24 07:43:14 Etc/GMT\";\n        \t\"original_purchase_date_ms\" = 1406187794660;\n        \t\"original_purchase_date_pst\" = \"2014-07-24 00:43:14 America/Los_Angeles\";\n        \t\"original_transaction_id\" = 1000000117879059;\n        \t\"product_id\" = \"com.netease.sdk.test.item2\";\n        \t\"purchase_date\" = \"2014-07-24 07:43:14 Etc/GMT\";\n        \t\"purchase_date_ms\" = 1406187794660;\n        \t\"purchase_date_pst\" = \"2014-07-24 00:43:14 America/Los_Angeles\";\n        \tquantity = 1;\n        \t\"transaction_id\" = 1000000117879059;\n        \t\"unique_identifier\" = 0000b0196818;\n        \t\"unique_vendor_identifier\" = \"FEF4F2DB-D07D-4B96-8F22-592A4B9CBAE7\";\n    \t};\n    \tstatus = 0;\n\t}\n\n而新接口返回的receipt：\n\n\t2014-07-24 17:11:16.475 [NetEase]iOSNtUniSdkFrameworkDemo[185:748f] [NtUniSdk] IAP jsonResponse: {\n    \tenvironment = Sandbox;\n    \treceipt =     {\n        \t\"adam_id\" = 0;\n        \t\"application_version\" = \"1.0\";\n        \t\"bundle_id\" = \"com.netease.sdk.test\";\n        \t\"download_id\" = 0;\n        \t\"in_app\" =         (\n                        \t{\n                \t\"is_trial_period\" = false;\n                \t\"original_purchase_date\" = \"2014-07-24 09:11:00 Etc/GMT\";\n                \t\"original_purchase_date_ms\" = 1406193060000;\n                \t\"original_purchase_date_pst\" = \"2014-07-24 02:11:00 America/Los_Angeles\";\n                \t\"original_transaction_id\" = 1000000117894869;\n                \t\"product_id\" = \"com.netease.sdk.test.item2\";\n                \t\"purchase_date\" = \"2014-07-24 09:11:01 Etc/GMT\";\n                \t\"purchase_date_ms\" = 1406193061000;\n                \t\"purchase_date_pst\" = \"2014-07-24 02:11:01 America/Los_Angeles\";\n                \tquantity = 1;\n                \t\"transaction_id\" = 1000000117894869;\n            \t}\n        \t);\n        \t\"original_application_version\" = \"1.0\";\n        \t\"original_purchase_date\" = \"2013-08-01 07:00:00 Etc/GMT\";\n        \t\"original_purchase_date_ms\" = 1375340400000;\n        \t\"original_purchase_date_pst\" = \"2013-08-01 00:00:00 America/Los_Angeles\";\n        \t\"receipt_type\" = ProductionSandbox;\n        \t\"request_date\" = \"2014-07-24 09:11:17 Etc/GMT\";\n        \t\"request_date_ms\" = 1406193077021;\n        \t\"request_date_pst\" = \"2014-07-24 02:11:17 America/Los_Angeles\";\n    \t};\n    \tstatus = 0;\n\t}\n\n新旧receipt在验证API接口方面无变化，变化主要在于返回的jsonResponese格式。\n新的jsonResponese格式官网文档如下：\n>Receipt Fields\n>https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html#//apple_ref/doc/uid/TP40010573-CH106-SW1\n\n下面是程序中实际输出jsonResponese的Log，值得注意的有receipt字段中的in_app字段可能包含多个transaction的receipt。\n客户端APP中的新接口每次读取将读取出还没读取过的所有receipt，当上一次transaction完成后，但没有成功调用到读取receipt接口时，即将出现多条，如下第二条Log所示。\n\n\t2014-07-24 16:06:52.077 [NetEase]iOSNtUniSdkFrameworkDemo[164:3e0b] [NtUniSdk] IAP jsonResponse: {\n    \tenvironment = Sandbox;\n    \treceipt =     {\n        \t\"adam_id\" = 0;\n        \t\"application_version\" = \"1.0\";\n        \t\"bundle_id\" = \"com.netease.sdk.test\";\n        \t\"download_id\" = 0;\n        \t\"in_app\" =         (\n            \t            {\n                \t\"is_trial_period\" = false;\n                \t\"original_purchase_date\" = \"2014-06-23 06:59:55 Etc/GMT\";\n                \t\"original_purchase_date_ms\" = 1403506795000;\n                \t\"original_purchase_date_pst\" = \"2014-06-22 23:59:55 America/Los_Angeles\";\n                \t\"original_transaction_id\" = 1000000114795007;\n                \t\"product_id\" = \"com.netease.sdk.test.item1\";\n                \t\"purchase_date\" = \"2014-06-24 09:06:09 Etc/GMT\";\n                \t\"purchase_date_ms\" = 1403600769000;\n                \t\"purchase_date_pst\" = \"2014-06-24 02:06:09 America/Los_Angeles\";\n                \tquantity = 1;\n                \t\"transaction_id\" = 1000000114795007;\n            \t},\n                \t        {\n                \t\"is_trial_period\" = false;\n                \t\"original_purchase_date\" = \"2014-06-24 09:06:09 Etc/GMT\";\n                \t\"original_purchase_date_ms\" = 1403600769000;\n                \t\"original_purchase_date_pst\" = \"2014-06-24 02:06:09 America/Los_Angeles\";\n                \t\"original_transaction_id\" = 1000000114938703;\n                \t\"product_id\" = \"com.netease.sdk.test.item3\";\n                \t\"purchase_date\" = \"2014-06-24 09:06:09 Etc/GMT\";\n                \t\"purchase_date_ms\" = 1403600769000;\n                \t\"purchase_date_pst\" = \"2014-06-24 02:06:09 America/Los_Angeles\";\n                \tquantity = 1;\n                \t\"transaction_id\" = 1000000114938703;\n            \t}\n        \t);\n        \t\"original_application_version\" = \"1.0\";\n        \t\"original_purchase_date\" = \"2013-08-01 07:00:00 Etc/GMT\";\n        \t\"original_purchase_date_ms\" = 1375340400000;\n        \t\"original_purchase_date_pst\" = \"2013-08-01 00:00:00 America/Los_Angeles\";\n        \t\"receipt_type\" = ProductionSandbox;\n        \t\"request_date\" = \"2014-07-24 08:06:54 Etc/GMT\";\n        \t\"request_date_ms\" = 1406189214105;\n        \t\"request_date_pst\" = \"2014-07-24 01:06:54 America/Los_Angeles\";\n   \t\t};\n    \tstatus = 0;\n\t}\n\nApple的IAP一直存在一个比较蛋疼的问题，在IAP的交易订单上没有填写额外信息的地方。由于存在网游的账号和AppStore支付账号两套系统，道具发放一直存在着可能在支付过程意外中断而导致漏洞的情况。iOS7.0在SKPayment中提供了一个applicationUsername属性用于填写用户信息，不过鉴于iOS7.0－的系统中没有该属性，在短时间内对这种意外情况改善也不大。\n\n","source":"_posts/About_IAP_Receipt.md","raw":"title: 关于AppStore IAP的新旧Receipt \ndate: 2014-08-17 21:27:40\ntags: [iOS,IAP,Receipt]\n---\n\niOS7.0后，SKPayment的property transactionReceipt变成了DEPRECATED。\n\n建议使用新接口来实现receipt的获取。\n\n\t [[[NSBundle mainBundle] appStoreReceiptURL] dataWithContentsOfURL:receiptURL];\n\n如果使用了IAP，Apple官方的建议是使用下列代码来处理：\n\n    NSData *receipt = nil;\n    \n    if (floor(NSFoundationVersionNumber) <= NSFoundationVersionNumber_iOS_6_1) {\n        // Load resources for iOS 6.1 or earlier\n        receipt = transaction.transactionReceipt;\n        \n    } else {\n        NSURL *receiptURL = [[NSBundle mainBundle] appStoreReceiptURL];\n        receipt = [NSData dataWithContentsOfURL:receiptURL];\n    }\n\n上面的代码很容易以为，新旧接口取得的receipt格式是一致的。其实不然。\n\n <!-- more --> \n\n在NtUniSdk里面,iOS官方渠道的易信和网易通行证使用了IAP,然后使用了上述Apple官方建议的代码，结果就是receipt格式不一致，计费验证不通过，把接入SDK的G3坑了一顿。\n\n原来旧接口返回的receipt如下：\n\n\t2014-07-24 15:53:51.284 [NetEase]iOSNtUniSdkFrameworkDemo[22831:4107] [NtUniSdk] IAP jsonResponse: {\n    \treceipt =     {\n        \tbid = \"com.netease.sdk.test\";\n        \tbvrs = \"1.0\";\n        \t\"item_id\" = 892617314;\n        \t\"original_purchase_date\" = \"2014-07-24 07:43:14 Etc/GMT\";\n        \t\"original_purchase_date_ms\" = 1406187794660;\n        \t\"original_purchase_date_pst\" = \"2014-07-24 00:43:14 America/Los_Angeles\";\n        \t\"original_transaction_id\" = 1000000117879059;\n        \t\"product_id\" = \"com.netease.sdk.test.item2\";\n        \t\"purchase_date\" = \"2014-07-24 07:43:14 Etc/GMT\";\n        \t\"purchase_date_ms\" = 1406187794660;\n        \t\"purchase_date_pst\" = \"2014-07-24 00:43:14 America/Los_Angeles\";\n        \tquantity = 1;\n        \t\"transaction_id\" = 1000000117879059;\n        \t\"unique_identifier\" = 0000b0196818;\n        \t\"unique_vendor_identifier\" = \"FEF4F2DB-D07D-4B96-8F22-592A4B9CBAE7\";\n    \t};\n    \tstatus = 0;\n\t}\n\n而新接口返回的receipt：\n\n\t2014-07-24 17:11:16.475 [NetEase]iOSNtUniSdkFrameworkDemo[185:748f] [NtUniSdk] IAP jsonResponse: {\n    \tenvironment = Sandbox;\n    \treceipt =     {\n        \t\"adam_id\" = 0;\n        \t\"application_version\" = \"1.0\";\n        \t\"bundle_id\" = \"com.netease.sdk.test\";\n        \t\"download_id\" = 0;\n        \t\"in_app\" =         (\n                        \t{\n                \t\"is_trial_period\" = false;\n                \t\"original_purchase_date\" = \"2014-07-24 09:11:00 Etc/GMT\";\n                \t\"original_purchase_date_ms\" = 1406193060000;\n                \t\"original_purchase_date_pst\" = \"2014-07-24 02:11:00 America/Los_Angeles\";\n                \t\"original_transaction_id\" = 1000000117894869;\n                \t\"product_id\" = \"com.netease.sdk.test.item2\";\n                \t\"purchase_date\" = \"2014-07-24 09:11:01 Etc/GMT\";\n                \t\"purchase_date_ms\" = 1406193061000;\n                \t\"purchase_date_pst\" = \"2014-07-24 02:11:01 America/Los_Angeles\";\n                \tquantity = 1;\n                \t\"transaction_id\" = 1000000117894869;\n            \t}\n        \t);\n        \t\"original_application_version\" = \"1.0\";\n        \t\"original_purchase_date\" = \"2013-08-01 07:00:00 Etc/GMT\";\n        \t\"original_purchase_date_ms\" = 1375340400000;\n        \t\"original_purchase_date_pst\" = \"2013-08-01 00:00:00 America/Los_Angeles\";\n        \t\"receipt_type\" = ProductionSandbox;\n        \t\"request_date\" = \"2014-07-24 09:11:17 Etc/GMT\";\n        \t\"request_date_ms\" = 1406193077021;\n        \t\"request_date_pst\" = \"2014-07-24 02:11:17 America/Los_Angeles\";\n    \t};\n    \tstatus = 0;\n\t}\n\n新旧receipt在验证API接口方面无变化，变化主要在于返回的jsonResponese格式。\n新的jsonResponese格式官网文档如下：\n>Receipt Fields\n>https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html#//apple_ref/doc/uid/TP40010573-CH106-SW1\n\n下面是程序中实际输出jsonResponese的Log，值得注意的有receipt字段中的in_app字段可能包含多个transaction的receipt。\n客户端APP中的新接口每次读取将读取出还没读取过的所有receipt，当上一次transaction完成后，但没有成功调用到读取receipt接口时，即将出现多条，如下第二条Log所示。\n\n\t2014-07-24 16:06:52.077 [NetEase]iOSNtUniSdkFrameworkDemo[164:3e0b] [NtUniSdk] IAP jsonResponse: {\n    \tenvironment = Sandbox;\n    \treceipt =     {\n        \t\"adam_id\" = 0;\n        \t\"application_version\" = \"1.0\";\n        \t\"bundle_id\" = \"com.netease.sdk.test\";\n        \t\"download_id\" = 0;\n        \t\"in_app\" =         (\n            \t            {\n                \t\"is_trial_period\" = false;\n                \t\"original_purchase_date\" = \"2014-06-23 06:59:55 Etc/GMT\";\n                \t\"original_purchase_date_ms\" = 1403506795000;\n                \t\"original_purchase_date_pst\" = \"2014-06-22 23:59:55 America/Los_Angeles\";\n                \t\"original_transaction_id\" = 1000000114795007;\n                \t\"product_id\" = \"com.netease.sdk.test.item1\";\n                \t\"purchase_date\" = \"2014-06-24 09:06:09 Etc/GMT\";\n                \t\"purchase_date_ms\" = 1403600769000;\n                \t\"purchase_date_pst\" = \"2014-06-24 02:06:09 America/Los_Angeles\";\n                \tquantity = 1;\n                \t\"transaction_id\" = 1000000114795007;\n            \t},\n                \t        {\n                \t\"is_trial_period\" = false;\n                \t\"original_purchase_date\" = \"2014-06-24 09:06:09 Etc/GMT\";\n                \t\"original_purchase_date_ms\" = 1403600769000;\n                \t\"original_purchase_date_pst\" = \"2014-06-24 02:06:09 America/Los_Angeles\";\n                \t\"original_transaction_id\" = 1000000114938703;\n                \t\"product_id\" = \"com.netease.sdk.test.item3\";\n                \t\"purchase_date\" = \"2014-06-24 09:06:09 Etc/GMT\";\n                \t\"purchase_date_ms\" = 1403600769000;\n                \t\"purchase_date_pst\" = \"2014-06-24 02:06:09 America/Los_Angeles\";\n                \tquantity = 1;\n                \t\"transaction_id\" = 1000000114938703;\n            \t}\n        \t);\n        \t\"original_application_version\" = \"1.0\";\n        \t\"original_purchase_date\" = \"2013-08-01 07:00:00 Etc/GMT\";\n        \t\"original_purchase_date_ms\" = 1375340400000;\n        \t\"original_purchase_date_pst\" = \"2013-08-01 00:00:00 America/Los_Angeles\";\n        \t\"receipt_type\" = ProductionSandbox;\n        \t\"request_date\" = \"2014-07-24 08:06:54 Etc/GMT\";\n        \t\"request_date_ms\" = 1406189214105;\n        \t\"request_date_pst\" = \"2014-07-24 01:06:54 America/Los_Angeles\";\n   \t\t};\n    \tstatus = 0;\n\t}\n\nApple的IAP一直存在一个比较蛋疼的问题，在IAP的交易订单上没有填写额外信息的地方。由于存在网游的账号和AppStore支付账号两套系统，道具发放一直存在着可能在支付过程意外中断而导致漏洞的情况。iOS7.0在SKPayment中提供了一个applicationUsername属性用于填写用户信息，不过鉴于iOS7.0－的系统中没有该属性，在短时间内对这种意外情况改善也不大。\n\n","slug":"About_IAP_Receipt","published":1,"updated":"2016-08-08T11:42:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civzfqikz0007f66oxhbbuvyf","content":"<p>iOS7.0后，SKPayment的property transactionReceipt变成了DEPRECATED。</p>\n<p>建议使用新接口来实现receipt的获取。</p>\n<pre><code>[[[NSBundle mainBundle] appStoreReceiptURL] dataWithContentsOfURL:receiptURL];\n</code></pre><p>如果使用了IAP，Apple官方的建议是使用下列代码来处理：</p>\n<pre><code>NSData *receipt = nil;\n\nif (floor(NSFoundationVersionNumber) &lt;= NSFoundationVersionNumber_iOS_6_1) {\n    // Load resources for iOS 6.1 or earlier\n    receipt = transaction.transactionReceipt;\n\n} else {\n    NSURL *receiptURL = [[NSBundle mainBundle] appStoreReceiptURL];\n    receipt = [NSData dataWithContentsOfURL:receiptURL];\n}\n</code></pre><p>上面的代码很容易以为，新旧接口取得的receipt格式是一致的。其实不然。</p>\n <a id=\"more\"></a> \n<p>在NtUniSdk里面,iOS官方渠道的易信和网易通行证使用了IAP,然后使用了上述Apple官方建议的代码，结果就是receipt格式不一致，计费验证不通过，把接入SDK的G3坑了一顿。</p>\n<p>原来旧接口返回的receipt如下：</p>\n<pre><code>2014-07-24 15:53:51.284 [NetEase]iOSNtUniSdkFrameworkDemo[22831:4107] [NtUniSdk] IAP jsonResponse: {\n    receipt =     {\n        bid = &quot;com.netease.sdk.test&quot;;\n        bvrs = &quot;1.0&quot;;\n        &quot;item_id&quot; = 892617314;\n        &quot;original_purchase_date&quot; = &quot;2014-07-24 07:43:14 Etc/GMT&quot;;\n        &quot;original_purchase_date_ms&quot; = 1406187794660;\n        &quot;original_purchase_date_pst&quot; = &quot;2014-07-24 00:43:14 America/Los_Angeles&quot;;\n        &quot;original_transaction_id&quot; = 1000000117879059;\n        &quot;product_id&quot; = &quot;com.netease.sdk.test.item2&quot;;\n        &quot;purchase_date&quot; = &quot;2014-07-24 07:43:14 Etc/GMT&quot;;\n        &quot;purchase_date_ms&quot; = 1406187794660;\n        &quot;purchase_date_pst&quot; = &quot;2014-07-24 00:43:14 America/Los_Angeles&quot;;\n        quantity = 1;\n        &quot;transaction_id&quot; = 1000000117879059;\n        &quot;unique_identifier&quot; = 0000b0196818;\n        &quot;unique_vendor_identifier&quot; = &quot;FEF4F2DB-D07D-4B96-8F22-592A4B9CBAE7&quot;;\n    };\n    status = 0;\n}\n</code></pre><p>而新接口返回的receipt：</p>\n<pre><code>2014-07-24 17:11:16.475 [NetEase]iOSNtUniSdkFrameworkDemo[185:748f] [NtUniSdk] IAP jsonResponse: {\n    environment = Sandbox;\n    receipt =     {\n        &quot;adam_id&quot; = 0;\n        &quot;application_version&quot; = &quot;1.0&quot;;\n        &quot;bundle_id&quot; = &quot;com.netease.sdk.test&quot;;\n        &quot;download_id&quot; = 0;\n        &quot;in_app&quot; =         (\n                        {\n                &quot;is_trial_period&quot; = false;\n                &quot;original_purchase_date&quot; = &quot;2014-07-24 09:11:00 Etc/GMT&quot;;\n                &quot;original_purchase_date_ms&quot; = 1406193060000;\n                &quot;original_purchase_date_pst&quot; = &quot;2014-07-24 02:11:00 America/Los_Angeles&quot;;\n                &quot;original_transaction_id&quot; = 1000000117894869;\n                &quot;product_id&quot; = &quot;com.netease.sdk.test.item2&quot;;\n                &quot;purchase_date&quot; = &quot;2014-07-24 09:11:01 Etc/GMT&quot;;\n                &quot;purchase_date_ms&quot; = 1406193061000;\n                &quot;purchase_date_pst&quot; = &quot;2014-07-24 02:11:01 America/Los_Angeles&quot;;\n                quantity = 1;\n                &quot;transaction_id&quot; = 1000000117894869;\n            }\n        );\n        &quot;original_application_version&quot; = &quot;1.0&quot;;\n        &quot;original_purchase_date&quot; = &quot;2013-08-01 07:00:00 Etc/GMT&quot;;\n        &quot;original_purchase_date_ms&quot; = 1375340400000;\n        &quot;original_purchase_date_pst&quot; = &quot;2013-08-01 00:00:00 America/Los_Angeles&quot;;\n        &quot;receipt_type&quot; = ProductionSandbox;\n        &quot;request_date&quot; = &quot;2014-07-24 09:11:17 Etc/GMT&quot;;\n        &quot;request_date_ms&quot; = 1406193077021;\n        &quot;request_date_pst&quot; = &quot;2014-07-24 02:11:17 America/Los_Angeles&quot;;\n    };\n    status = 0;\n}\n</code></pre><p>新旧receipt在验证API接口方面无变化，变化主要在于返回的jsonResponese格式。<br>新的jsonResponese格式官网文档如下：</p>\n<blockquote>\n<p>Receipt Fields<br><a href=\"https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html#//apple_ref/doc/uid/TP40010573-CH106-SW1\" target=\"_blank\" rel=\"external\">https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html#//apple_ref/doc/uid/TP40010573-CH106-SW1</a></p>\n</blockquote>\n<p>下面是程序中实际输出jsonResponese的Log，值得注意的有receipt字段中的in_app字段可能包含多个transaction的receipt。<br>客户端APP中的新接口每次读取将读取出还没读取过的所有receipt，当上一次transaction完成后，但没有成功调用到读取receipt接口时，即将出现多条，如下第二条Log所示。</p>\n<pre><code>2014-07-24 16:06:52.077 [NetEase]iOSNtUniSdkFrameworkDemo[164:3e0b] [NtUniSdk] IAP jsonResponse: {\n    environment = Sandbox;\n    receipt =     {\n        &quot;adam_id&quot; = 0;\n        &quot;application_version&quot; = &quot;1.0&quot;;\n        &quot;bundle_id&quot; = &quot;com.netease.sdk.test&quot;;\n        &quot;download_id&quot; = 0;\n        &quot;in_app&quot; =         (\n                        {\n                &quot;is_trial_period&quot; = false;\n                &quot;original_purchase_date&quot; = &quot;2014-06-23 06:59:55 Etc/GMT&quot;;\n                &quot;original_purchase_date_ms&quot; = 1403506795000;\n                &quot;original_purchase_date_pst&quot; = &quot;2014-06-22 23:59:55 America/Los_Angeles&quot;;\n                &quot;original_transaction_id&quot; = 1000000114795007;\n                &quot;product_id&quot; = &quot;com.netease.sdk.test.item1&quot;;\n                &quot;purchase_date&quot; = &quot;2014-06-24 09:06:09 Etc/GMT&quot;;\n                &quot;purchase_date_ms&quot; = 1403600769000;\n                &quot;purchase_date_pst&quot; = &quot;2014-06-24 02:06:09 America/Los_Angeles&quot;;\n                quantity = 1;\n                &quot;transaction_id&quot; = 1000000114795007;\n            },\n                        {\n                &quot;is_trial_period&quot; = false;\n                &quot;original_purchase_date&quot; = &quot;2014-06-24 09:06:09 Etc/GMT&quot;;\n                &quot;original_purchase_date_ms&quot; = 1403600769000;\n                &quot;original_purchase_date_pst&quot; = &quot;2014-06-24 02:06:09 America/Los_Angeles&quot;;\n                &quot;original_transaction_id&quot; = 1000000114938703;\n                &quot;product_id&quot; = &quot;com.netease.sdk.test.item3&quot;;\n                &quot;purchase_date&quot; = &quot;2014-06-24 09:06:09 Etc/GMT&quot;;\n                &quot;purchase_date_ms&quot; = 1403600769000;\n                &quot;purchase_date_pst&quot; = &quot;2014-06-24 02:06:09 America/Los_Angeles&quot;;\n                quantity = 1;\n                &quot;transaction_id&quot; = 1000000114938703;\n            }\n        );\n        &quot;original_application_version&quot; = &quot;1.0&quot;;\n        &quot;original_purchase_date&quot; = &quot;2013-08-01 07:00:00 Etc/GMT&quot;;\n        &quot;original_purchase_date_ms&quot; = 1375340400000;\n        &quot;original_purchase_date_pst&quot; = &quot;2013-08-01 00:00:00 America/Los_Angeles&quot;;\n        &quot;receipt_type&quot; = ProductionSandbox;\n        &quot;request_date&quot; = &quot;2014-07-24 08:06:54 Etc/GMT&quot;;\n        &quot;request_date_ms&quot; = 1406189214105;\n        &quot;request_date_pst&quot; = &quot;2014-07-24 01:06:54 America/Los_Angeles&quot;;\n       };\n    status = 0;\n}\n</code></pre><p>Apple的IAP一直存在一个比较蛋疼的问题，在IAP的交易订单上没有填写额外信息的地方。由于存在网游的账号和AppStore支付账号两套系统，道具发放一直存在着可能在支付过程意外中断而导致漏洞的情况。iOS7.0在SKPayment中提供了一个applicationUsername属性用于填写用户信息，不过鉴于iOS7.0－的系统中没有该属性，在短时间内对这种意外情况改善也不大。</p>\n","excerpt":"<p>iOS7.0后，SKPayment的property transactionReceipt变成了DEPRECATED。</p>\n<p>建议使用新接口来实现receipt的获取。</p>\n<pre><code>[[[NSBundle mainBundle] appStoreReceiptURL] dataWithContentsOfURL:receiptURL];\n</code></pre><p>如果使用了IAP，Apple官方的建议是使用下列代码来处理：</p>\n<pre><code>NSData *receipt = nil;\n\nif (floor(NSFoundationVersionNumber) &lt;= NSFoundationVersionNumber_iOS_6_1) {\n    // Load resources for iOS 6.1 or earlier\n    receipt = transaction.transactionReceipt;\n\n} else {\n    NSURL *receiptURL = [[NSBundle mainBundle] appStoreReceiptURL];\n    receipt = [NSData dataWithContentsOfURL:receiptURL];\n}\n</code></pre><p>上面的代码很容易以为，新旧接口取得的receipt格式是一致的。其实不然。</p>","more":"<p>在NtUniSdk里面,iOS官方渠道的易信和网易通行证使用了IAP,然后使用了上述Apple官方建议的代码，结果就是receipt格式不一致，计费验证不通过，把接入SDK的G3坑了一顿。</p>\n<p>原来旧接口返回的receipt如下：</p>\n<pre><code>2014-07-24 15:53:51.284 [NetEase]iOSNtUniSdkFrameworkDemo[22831:4107] [NtUniSdk] IAP jsonResponse: {\n    receipt =     {\n        bid = &quot;com.netease.sdk.test&quot;;\n        bvrs = &quot;1.0&quot;;\n        &quot;item_id&quot; = 892617314;\n        &quot;original_purchase_date&quot; = &quot;2014-07-24 07:43:14 Etc/GMT&quot;;\n        &quot;original_purchase_date_ms&quot; = 1406187794660;\n        &quot;original_purchase_date_pst&quot; = &quot;2014-07-24 00:43:14 America/Los_Angeles&quot;;\n        &quot;original_transaction_id&quot; = 1000000117879059;\n        &quot;product_id&quot; = &quot;com.netease.sdk.test.item2&quot;;\n        &quot;purchase_date&quot; = &quot;2014-07-24 07:43:14 Etc/GMT&quot;;\n        &quot;purchase_date_ms&quot; = 1406187794660;\n        &quot;purchase_date_pst&quot; = &quot;2014-07-24 00:43:14 America/Los_Angeles&quot;;\n        quantity = 1;\n        &quot;transaction_id&quot; = 1000000117879059;\n        &quot;unique_identifier&quot; = 0000b0196818;\n        &quot;unique_vendor_identifier&quot; = &quot;FEF4F2DB-D07D-4B96-8F22-592A4B9CBAE7&quot;;\n    };\n    status = 0;\n}\n</code></pre><p>而新接口返回的receipt：</p>\n<pre><code>2014-07-24 17:11:16.475 [NetEase]iOSNtUniSdkFrameworkDemo[185:748f] [NtUniSdk] IAP jsonResponse: {\n    environment = Sandbox;\n    receipt =     {\n        &quot;adam_id&quot; = 0;\n        &quot;application_version&quot; = &quot;1.0&quot;;\n        &quot;bundle_id&quot; = &quot;com.netease.sdk.test&quot;;\n        &quot;download_id&quot; = 0;\n        &quot;in_app&quot; =         (\n                        {\n                &quot;is_trial_period&quot; = false;\n                &quot;original_purchase_date&quot; = &quot;2014-07-24 09:11:00 Etc/GMT&quot;;\n                &quot;original_purchase_date_ms&quot; = 1406193060000;\n                &quot;original_purchase_date_pst&quot; = &quot;2014-07-24 02:11:00 America/Los_Angeles&quot;;\n                &quot;original_transaction_id&quot; = 1000000117894869;\n                &quot;product_id&quot; = &quot;com.netease.sdk.test.item2&quot;;\n                &quot;purchase_date&quot; = &quot;2014-07-24 09:11:01 Etc/GMT&quot;;\n                &quot;purchase_date_ms&quot; = 1406193061000;\n                &quot;purchase_date_pst&quot; = &quot;2014-07-24 02:11:01 America/Los_Angeles&quot;;\n                quantity = 1;\n                &quot;transaction_id&quot; = 1000000117894869;\n            }\n        );\n        &quot;original_application_version&quot; = &quot;1.0&quot;;\n        &quot;original_purchase_date&quot; = &quot;2013-08-01 07:00:00 Etc/GMT&quot;;\n        &quot;original_purchase_date_ms&quot; = 1375340400000;\n        &quot;original_purchase_date_pst&quot; = &quot;2013-08-01 00:00:00 America/Los_Angeles&quot;;\n        &quot;receipt_type&quot; = ProductionSandbox;\n        &quot;request_date&quot; = &quot;2014-07-24 09:11:17 Etc/GMT&quot;;\n        &quot;request_date_ms&quot; = 1406193077021;\n        &quot;request_date_pst&quot; = &quot;2014-07-24 02:11:17 America/Los_Angeles&quot;;\n    };\n    status = 0;\n}\n</code></pre><p>新旧receipt在验证API接口方面无变化，变化主要在于返回的jsonResponese格式。<br>新的jsonResponese格式官网文档如下：</p>\n<blockquote>\n<p>Receipt Fields<br><a href=\"https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html#//apple_ref/doc/uid/TP40010573-CH106-SW1\">https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html#//apple_ref/doc/uid/TP40010573-CH106-SW1</a></p>\n</blockquote>\n<p>下面是程序中实际输出jsonResponese的Log，值得注意的有receipt字段中的in_app字段可能包含多个transaction的receipt。<br>客户端APP中的新接口每次读取将读取出还没读取过的所有receipt，当上一次transaction完成后，但没有成功调用到读取receipt接口时，即将出现多条，如下第二条Log所示。</p>\n<pre><code>2014-07-24 16:06:52.077 [NetEase]iOSNtUniSdkFrameworkDemo[164:3e0b] [NtUniSdk] IAP jsonResponse: {\n    environment = Sandbox;\n    receipt =     {\n        &quot;adam_id&quot; = 0;\n        &quot;application_version&quot; = &quot;1.0&quot;;\n        &quot;bundle_id&quot; = &quot;com.netease.sdk.test&quot;;\n        &quot;download_id&quot; = 0;\n        &quot;in_app&quot; =         (\n                        {\n                &quot;is_trial_period&quot; = false;\n                &quot;original_purchase_date&quot; = &quot;2014-06-23 06:59:55 Etc/GMT&quot;;\n                &quot;original_purchase_date_ms&quot; = 1403506795000;\n                &quot;original_purchase_date_pst&quot; = &quot;2014-06-22 23:59:55 America/Los_Angeles&quot;;\n                &quot;original_transaction_id&quot; = 1000000114795007;\n                &quot;product_id&quot; = &quot;com.netease.sdk.test.item1&quot;;\n                &quot;purchase_date&quot; = &quot;2014-06-24 09:06:09 Etc/GMT&quot;;\n                &quot;purchase_date_ms&quot; = 1403600769000;\n                &quot;purchase_date_pst&quot; = &quot;2014-06-24 02:06:09 America/Los_Angeles&quot;;\n                quantity = 1;\n                &quot;transaction_id&quot; = 1000000114795007;\n            },\n                        {\n                &quot;is_trial_period&quot; = false;\n                &quot;original_purchase_date&quot; = &quot;2014-06-24 09:06:09 Etc/GMT&quot;;\n                &quot;original_purchase_date_ms&quot; = 1403600769000;\n                &quot;original_purchase_date_pst&quot; = &quot;2014-06-24 02:06:09 America/Los_Angeles&quot;;\n                &quot;original_transaction_id&quot; = 1000000114938703;\n                &quot;product_id&quot; = &quot;com.netease.sdk.test.item3&quot;;\n                &quot;purchase_date&quot; = &quot;2014-06-24 09:06:09 Etc/GMT&quot;;\n                &quot;purchase_date_ms&quot; = 1403600769000;\n                &quot;purchase_date_pst&quot; = &quot;2014-06-24 02:06:09 America/Los_Angeles&quot;;\n                quantity = 1;\n                &quot;transaction_id&quot; = 1000000114938703;\n            }\n        );\n        &quot;original_application_version&quot; = &quot;1.0&quot;;\n        &quot;original_purchase_date&quot; = &quot;2013-08-01 07:00:00 Etc/GMT&quot;;\n        &quot;original_purchase_date_ms&quot; = 1375340400000;\n        &quot;original_purchase_date_pst&quot; = &quot;2013-08-01 00:00:00 America/Los_Angeles&quot;;\n        &quot;receipt_type&quot; = ProductionSandbox;\n        &quot;request_date&quot; = &quot;2014-07-24 08:06:54 Etc/GMT&quot;;\n        &quot;request_date_ms&quot; = 1406189214105;\n        &quot;request_date_pst&quot; = &quot;2014-07-24 01:06:54 America/Los_Angeles&quot;;\n       };\n    status = 0;\n}\n</code></pre><p>Apple的IAP一直存在一个比较蛋疼的问题，在IAP的交易订单上没有填写额外信息的地方。由于存在网游的账号和AppStore支付账号两套系统，道具发放一直存在着可能在支付过程意外中断而导致漏洞的情况。iOS7.0在SKPayment中提供了一个applicationUsername属性用于填写用户信息，不过鉴于iOS7.0－的系统中没有该属性，在短时间内对这种意外情况改善也不大。</p>"},{"title":"关于NavMesh，我所知道的","date":"2016-08-20T18:37:42.000Z","_content":"\n这是一篇关于NavMesh的资料整理和总结笔记。整理了前段时间收集的NavMesh相关的资料和一个简单的算法描述。\n\n*（文章出现的所有算法描述和资料均来源于互联网，绝无半点个人原创内容，请放心阅读。）*\n\n\n## Recast & Detour\nRecast & Detour [GITHUB PAGE](https://github.com/recastnavigation/recastnavigation) 是一个开源的游戏寻路引擎，被包括Unity，UE4等游戏引擎采用。\n\n![Recast & Detour](/images/About_NavMesh/Image_RecastAndDetour.png)\n\n<!-- more --> \n\nRecast & Detour 包括了两部分，即 Recast 和 Detour。\n\nRecast 通过将输入的场景模型体素化生成相应的寻路网格。其大概包括三个步骤：1. 体素化模型；2. 分割联通区域； 3. 将区域简化为多边形\n\nDetour 通过使用 Recast 生成的 NavMesh 进行寻路，其包括了许多算法，根据不同路径平滑程度和寻路效率要求可做不同选择。\n\n该开源库的作者 Mikko Mononen 在 AiGameDev.com 有一个相关的介绍视频 [Building and Traversing Navigation Meshes with Recast and Detour (Project Video)](http://aigamedev.com/insider/presentations/recast-teaser/)。\n\n\nMikko Mononen 在该文章 References 部分贴出了一系列相关的参考文献。\n\n+ **Conservative Voxelization**\nLong Zhang, Wei Chen, David S. Ebert, Qunsheng Peng\n[PDF](/files/About_NavMesh/P1_Conservative_voxelization.pdf)\n\n\n+ **Real-time Voxelization for Complex Polygonal Models**\nZhao Dong, Wei Chen, Hujun Bao, Hongxin Zhang, Qunsheng Peng\n[PDF](/files/About_NavMesh/P2_Real-time_Voxelization_for_Complex_Models.pdf)\n\n\n+ **Single-pass GPU Solid Voxelization and Applications**\nElmar Eisemann, Xavier Décoret\n[PDF](/files/About_NavMesh/P3_Single-Pass_GPU_Solid_Voxelization_for_Real-Time_Applications.pdf)\n\n\n+ **GPU Gems 2: Flow Simulation with Complex Boundaries**\nWei Li, Zhe Fan, Xiaoming Wei, Arie Kaufman\n[PDF](/files/About_NavMesh/P4_GPU_Gems_2_Chapter_47_Flow_Simulation_with_Complex_Boundaries.pdf)\n\n\n+ **GPU Gems 3: Real-Time Simulation and Rendering of 3D Fluids**\nKeenan Crane, Ignacio Llamas, Sarah Tariq\n[PDF](/files/About_NavMesh/P5_GPU_Gems_3_Real-Time_Simulation_and_Rendering_of_3D_Fluids.pdf)\n\n\n+ **Way-Finder: guided tours through complex walkthrough models**\nC. Andújar, P. Vázquez, M. Fairén\n[PDF](/files/About_NavMesh/P6_Way-Finder_guided_tours_through_complex_walkthrough_models.pdf)\n\n\n+ **Volumetric Cell-and-Portal Generation**\nDenis Haumont, Olivier Debeir, François Sillion\n[PDF](/files/About_NavMesh/P7_Volumetric_cell-and-portal_generation.pdf)\n\n+ **Skeleton Extraction of 3D Objects with Visible Repulsive Force**\nFu-Che Wu, Wan-Chun Ma, Ping-Chou Liou, Rung-Huei Liang, Ming Ouhyoung\n[PDF](/files/About_NavMesh/P8_Skeleton_Extraction_of 3D_Objects_with_Visible_Repulsive_Force.pdf)\n\n+ **Automated Static and Dynamic Obstacle Avoidance in Arbitrary 3D Polygonal Worlds**\nEdited by Xing-Jian Jing\n[PDF](/files/About_NavMesh/P9_Automated_Static_and Dynamic_ObstacleAvoidance_in_Arbitrary_3D_Polygonal_Worlds.pdf)\n\n\n+ **A Navigation Graph for Real-time Crowd Animation on Multilayered and Uneven Terrain**\nJulien Pettré, Jean-Paul Laumond, Daniel Thalmann\n[PDF](/files/About_NavMesh/P10_A_navigation_graph_for_real-time_crowd_animation_on_multilayered_and_uneven_terrain.pdf)\n\n\n+ **Pedestrian Reactive Navigation for Crowd Simulation: a Predictive Approach**\nSébastien Paris, Julien Pettré, Stéphane Donikian\n[PDF](/files/About_NavMesh/P11_Pedestrian_Reactive_Navigation_for_Crowd_Pedestrian_Reactive_Navigation_for_Crowd_Simulation_a_Predictive_Approach.pdf)\n\n## Study: Navigation Mesh Generation\nStephen Pratt 在其项目 [《Study: Navigation Mesh Generation》](http://www.critterai.org/projects/nmgen_study/index.html) 中提供了一个 Java 版本的 Recast 实现，并在文档中对算法细节及参数进行了详细的讨论。\n\n![Study: Navigation Mesh Generation](/images/About_NavMesh/Image_NavigationMeshGeneration.png)\n\n其中，\n\n+ [《Differences Between NMGen and Recast》](http://www.critterai.org/projects/nmgen_study/diffs.html)描述了其实现与 Recast & Detour 项目的异同之处；\n+ [《Configuration Parameters》](http://www.critterai.org/projects/nmgen_study/config.html)罗列了算法中各参数对生成寻路网格数据的影响。\n\n\n## Crowds In A Polygon Soup: Next-Gen Path Planning\nMikko Mononen 在 Recast & Detour 中生成NavMesh的基本流程受到 GDC2006 上演讲[《Crowds In A Polygon Soup: Next-Gen Path Planning》](http://gdcvault.com/play/1013192/Crowds-In-A-Polygon-Soup)的启发。\n\n+ **Session:  Crowds In A Polygon Soup: Next-Gen Path Planning**\nBy David Miles, David Miles, David Miles, David Miles\n\t\n\t+ [Session mp3](/files/About_NavMesh/GDC-06-038.mp3)\n\t+ [Session ppt](/files/About_NavMesh/gdc2006_miles_david_pathplanning.ppt)\n\n\n## 谷阿莫带你十分钟看完 NavMesh 生成算法\n没有时间看完上面资料的同学可以看下面这个《谷阿莫带你十分钟看完 NavMesh 生成算法》的小抄。\n\n![谷阿莫带你十分钟看完 NavMesh 生成算法](/images/About_NavMesh/Image[1].png)\n\n[谷阿莫带你十分钟看完 NavMesh 生成算法](/2016/08/21/A_Quick_Introduction_to_NavMesh/)\n","source":"_posts/About_NavMesh.md","raw":"title: 关于NavMesh，我所知道的\ndate: 2016-08-21 02:37:42\ntags: [Recast & Detour,NavMesh,Game]\n---\n\n这是一篇关于NavMesh的资料整理和总结笔记。整理了前段时间收集的NavMesh相关的资料和一个简单的算法描述。\n\n*（文章出现的所有算法描述和资料均来源于互联网，绝无半点个人原创内容，请放心阅读。）*\n\n\n## Recast & Detour\nRecast & Detour [GITHUB PAGE](https://github.com/recastnavigation/recastnavigation) 是一个开源的游戏寻路引擎，被包括Unity，UE4等游戏引擎采用。\n\n![Recast & Detour](/images/About_NavMesh/Image_RecastAndDetour.png)\n\n<!-- more --> \n\nRecast & Detour 包括了两部分，即 Recast 和 Detour。\n\nRecast 通过将输入的场景模型体素化生成相应的寻路网格。其大概包括三个步骤：1. 体素化模型；2. 分割联通区域； 3. 将区域简化为多边形\n\nDetour 通过使用 Recast 生成的 NavMesh 进行寻路，其包括了许多算法，根据不同路径平滑程度和寻路效率要求可做不同选择。\n\n该开源库的作者 Mikko Mononen 在 AiGameDev.com 有一个相关的介绍视频 [Building and Traversing Navigation Meshes with Recast and Detour (Project Video)](http://aigamedev.com/insider/presentations/recast-teaser/)。\n\n\nMikko Mononen 在该文章 References 部分贴出了一系列相关的参考文献。\n\n+ **Conservative Voxelization**\nLong Zhang, Wei Chen, David S. Ebert, Qunsheng Peng\n[PDF](/files/About_NavMesh/P1_Conservative_voxelization.pdf)\n\n\n+ **Real-time Voxelization for Complex Polygonal Models**\nZhao Dong, Wei Chen, Hujun Bao, Hongxin Zhang, Qunsheng Peng\n[PDF](/files/About_NavMesh/P2_Real-time_Voxelization_for_Complex_Models.pdf)\n\n\n+ **Single-pass GPU Solid Voxelization and Applications**\nElmar Eisemann, Xavier Décoret\n[PDF](/files/About_NavMesh/P3_Single-Pass_GPU_Solid_Voxelization_for_Real-Time_Applications.pdf)\n\n\n+ **GPU Gems 2: Flow Simulation with Complex Boundaries**\nWei Li, Zhe Fan, Xiaoming Wei, Arie Kaufman\n[PDF](/files/About_NavMesh/P4_GPU_Gems_2_Chapter_47_Flow_Simulation_with_Complex_Boundaries.pdf)\n\n\n+ **GPU Gems 3: Real-Time Simulation and Rendering of 3D Fluids**\nKeenan Crane, Ignacio Llamas, Sarah Tariq\n[PDF](/files/About_NavMesh/P5_GPU_Gems_3_Real-Time_Simulation_and_Rendering_of_3D_Fluids.pdf)\n\n\n+ **Way-Finder: guided tours through complex walkthrough models**\nC. Andújar, P. Vázquez, M. Fairén\n[PDF](/files/About_NavMesh/P6_Way-Finder_guided_tours_through_complex_walkthrough_models.pdf)\n\n\n+ **Volumetric Cell-and-Portal Generation**\nDenis Haumont, Olivier Debeir, François Sillion\n[PDF](/files/About_NavMesh/P7_Volumetric_cell-and-portal_generation.pdf)\n\n+ **Skeleton Extraction of 3D Objects with Visible Repulsive Force**\nFu-Che Wu, Wan-Chun Ma, Ping-Chou Liou, Rung-Huei Liang, Ming Ouhyoung\n[PDF](/files/About_NavMesh/P8_Skeleton_Extraction_of 3D_Objects_with_Visible_Repulsive_Force.pdf)\n\n+ **Automated Static and Dynamic Obstacle Avoidance in Arbitrary 3D Polygonal Worlds**\nEdited by Xing-Jian Jing\n[PDF](/files/About_NavMesh/P9_Automated_Static_and Dynamic_ObstacleAvoidance_in_Arbitrary_3D_Polygonal_Worlds.pdf)\n\n\n+ **A Navigation Graph for Real-time Crowd Animation on Multilayered and Uneven Terrain**\nJulien Pettré, Jean-Paul Laumond, Daniel Thalmann\n[PDF](/files/About_NavMesh/P10_A_navigation_graph_for_real-time_crowd_animation_on_multilayered_and_uneven_terrain.pdf)\n\n\n+ **Pedestrian Reactive Navigation for Crowd Simulation: a Predictive Approach**\nSébastien Paris, Julien Pettré, Stéphane Donikian\n[PDF](/files/About_NavMesh/P11_Pedestrian_Reactive_Navigation_for_Crowd_Pedestrian_Reactive_Navigation_for_Crowd_Simulation_a_Predictive_Approach.pdf)\n\n## Study: Navigation Mesh Generation\nStephen Pratt 在其项目 [《Study: Navigation Mesh Generation》](http://www.critterai.org/projects/nmgen_study/index.html) 中提供了一个 Java 版本的 Recast 实现，并在文档中对算法细节及参数进行了详细的讨论。\n\n![Study: Navigation Mesh Generation](/images/About_NavMesh/Image_NavigationMeshGeneration.png)\n\n其中，\n\n+ [《Differences Between NMGen and Recast》](http://www.critterai.org/projects/nmgen_study/diffs.html)描述了其实现与 Recast & Detour 项目的异同之处；\n+ [《Configuration Parameters》](http://www.critterai.org/projects/nmgen_study/config.html)罗列了算法中各参数对生成寻路网格数据的影响。\n\n\n## Crowds In A Polygon Soup: Next-Gen Path Planning\nMikko Mononen 在 Recast & Detour 中生成NavMesh的基本流程受到 GDC2006 上演讲[《Crowds In A Polygon Soup: Next-Gen Path Planning》](http://gdcvault.com/play/1013192/Crowds-In-A-Polygon-Soup)的启发。\n\n+ **Session:  Crowds In A Polygon Soup: Next-Gen Path Planning**\nBy David Miles, David Miles, David Miles, David Miles\n\t\n\t+ [Session mp3](/files/About_NavMesh/GDC-06-038.mp3)\n\t+ [Session ppt](/files/About_NavMesh/gdc2006_miles_david_pathplanning.ppt)\n\n\n## 谷阿莫带你十分钟看完 NavMesh 生成算法\n没有时间看完上面资料的同学可以看下面这个《谷阿莫带你十分钟看完 NavMesh 生成算法》的小抄。\n\n![谷阿莫带你十分钟看完 NavMesh 生成算法](/images/About_NavMesh/Image[1].png)\n\n[谷阿莫带你十分钟看完 NavMesh 生成算法](/2016/08/21/A_Quick_Introduction_to_NavMesh/)\n","slug":"About_NavMesh","published":1,"updated":"2016-10-01T17:24:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civzfqil10009f66okg6snkfa","content":"<p>这是一篇关于NavMesh的资料整理和总结笔记。整理了前段时间收集的NavMesh相关的资料和一个简单的算法描述。</p>\n<p><em>（文章出现的所有算法描述和资料均来源于互联网，绝无半点个人原创内容，请放心阅读。）</em></p>\n<h2 id=\"Recast-amp-Detour\"><a href=\"#Recast-amp-Detour\" class=\"headerlink\" title=\"Recast &amp; Detour\"></a>Recast &amp; Detour</h2><p>Recast &amp; Detour <a href=\"https://github.com/recastnavigation/recastnavigation\" target=\"_blank\" rel=\"external\">GITHUB PAGE</a> 是一个开源的游戏寻路引擎，被包括Unity，UE4等游戏引擎采用。</p>\n<p><img src=\"/images/About_NavMesh/Image_RecastAndDetour.png\" alt=\"Recast &amp; Detour\"></p>\n<a id=\"more\"></a> \n<p>Recast &amp; Detour 包括了两部分，即 Recast 和 Detour。</p>\n<p>Recast 通过将输入的场景模型体素化生成相应的寻路网格。其大概包括三个步骤：1. 体素化模型；2. 分割联通区域； 3. 将区域简化为多边形</p>\n<p>Detour 通过使用 Recast 生成的 NavMesh 进行寻路，其包括了许多算法，根据不同路径平滑程度和寻路效率要求可做不同选择。</p>\n<p>该开源库的作者 Mikko Mononen 在 AiGameDev.com 有一个相关的介绍视频 <a href=\"http://aigamedev.com/insider/presentations/recast-teaser/\" target=\"_blank\" rel=\"external\">Building and Traversing Navigation Meshes with Recast and Detour (Project Video)</a>。</p>\n<p>Mikko Mononen 在该文章 References 部分贴出了一系列相关的参考文献。</p>\n<ul>\n<li><strong>Conservative Voxelization</strong><br>Long Zhang, Wei Chen, David S. Ebert, Qunsheng Peng<br><a href=\"/files/About_NavMesh/P1_Conservative_voxelization.pdf\">PDF</a></li>\n</ul>\n<ul>\n<li><strong>Real-time Voxelization for Complex Polygonal Models</strong><br>Zhao Dong, Wei Chen, Hujun Bao, Hongxin Zhang, Qunsheng Peng<br><a href=\"/files/About_NavMesh/P2_Real-time_Voxelization_for_Complex_Models.pdf\">PDF</a></li>\n</ul>\n<ul>\n<li><strong>Single-pass GPU Solid Voxelization and Applications</strong><br>Elmar Eisemann, Xavier Décoret<br><a href=\"/files/About_NavMesh/P3_Single-Pass_GPU_Solid_Voxelization_for_Real-Time_Applications.pdf\">PDF</a></li>\n</ul>\n<ul>\n<li><strong>GPU Gems 2: Flow Simulation with Complex Boundaries</strong><br>Wei Li, Zhe Fan, Xiaoming Wei, Arie Kaufman<br><a href=\"/files/About_NavMesh/P4_GPU_Gems_2_Chapter_47_Flow_Simulation_with_Complex_Boundaries.pdf\">PDF</a></li>\n</ul>\n<ul>\n<li><strong>GPU Gems 3: Real-Time Simulation and Rendering of 3D Fluids</strong><br>Keenan Crane, Ignacio Llamas, Sarah Tariq<br><a href=\"/files/About_NavMesh/P5_GPU_Gems_3_Real-Time_Simulation_and_Rendering_of_3D_Fluids.pdf\">PDF</a></li>\n</ul>\n<ul>\n<li><strong>Way-Finder: guided tours through complex walkthrough models</strong><br>C. Andújar, P. Vázquez, M. Fairén<br><a href=\"/files/About_NavMesh/P6_Way-Finder_guided_tours_through_complex_walkthrough_models.pdf\">PDF</a></li>\n</ul>\n<ul>\n<li><p><strong>Volumetric Cell-and-Portal Generation</strong><br>Denis Haumont, Olivier Debeir, François Sillion<br><a href=\"/files/About_NavMesh/P7_Volumetric_cell-and-portal_generation.pdf\">PDF</a></p>\n</li>\n<li><p><strong>Skeleton Extraction of 3D Objects with Visible Repulsive Force</strong><br>Fu-Che Wu, Wan-Chun Ma, Ping-Chou Liou, Rung-Huei Liang, Ming Ouhyoung<br><a href=\"/files/About_NavMesh/P8_Skeleton_Extraction_of 3D_Objects_with_Visible_Repulsive_Force.pdf\">PDF</a></p>\n</li>\n<li><p><strong>Automated Static and Dynamic Obstacle Avoidance in Arbitrary 3D Polygonal Worlds</strong><br>Edited by Xing-Jian Jing<br><a href=\"/files/About_NavMesh/P9_Automated_Static_and Dynamic_ObstacleAvoidance_in_Arbitrary_3D_Polygonal_Worlds.pdf\">PDF</a></p>\n</li>\n</ul>\n<ul>\n<li><strong>A Navigation Graph for Real-time Crowd Animation on Multilayered and Uneven Terrain</strong><br>Julien Pettré, Jean-Paul Laumond, Daniel Thalmann<br><a href=\"/files/About_NavMesh/P10_A_navigation_graph_for_real-time_crowd_animation_on_multilayered_and_uneven_terrain.pdf\">PDF</a></li>\n</ul>\n<ul>\n<li><strong>Pedestrian Reactive Navigation for Crowd Simulation: a Predictive Approach</strong><br>Sébastien Paris, Julien Pettré, Stéphane Donikian<br><a href=\"/files/About_NavMesh/P11_Pedestrian_Reactive_Navigation_for_Crowd_Pedestrian_Reactive_Navigation_for_Crowd_Simulation_a_Predictive_Approach.pdf\">PDF</a></li>\n</ul>\n<h2 id=\"Study-Navigation-Mesh-Generation\"><a href=\"#Study-Navigation-Mesh-Generation\" class=\"headerlink\" title=\"Study: Navigation Mesh Generation\"></a>Study: Navigation Mesh Generation</h2><p>Stephen Pratt 在其项目 <a href=\"http://www.critterai.org/projects/nmgen_study/index.html\" target=\"_blank\" rel=\"external\">《Study: Navigation Mesh Generation》</a> 中提供了一个 Java 版本的 Recast 实现，并在文档中对算法细节及参数进行了详细的讨论。</p>\n<p><img src=\"/images/About_NavMesh/Image_NavigationMeshGeneration.png\" alt=\"Study: Navigation Mesh Generation\"></p>\n<p>其中，</p>\n<ul>\n<li><a href=\"http://www.critterai.org/projects/nmgen_study/diffs.html\" target=\"_blank\" rel=\"external\">《Differences Between NMGen and Recast》</a>描述了其实现与 Recast &amp; Detour 项目的异同之处；</li>\n<li><a href=\"http://www.critterai.org/projects/nmgen_study/config.html\" target=\"_blank\" rel=\"external\">《Configuration Parameters》</a>罗列了算法中各参数对生成寻路网格数据的影响。</li>\n</ul>\n<h2 id=\"Crowds-In-A-Polygon-Soup-Next-Gen-Path-Planning\"><a href=\"#Crowds-In-A-Polygon-Soup-Next-Gen-Path-Planning\" class=\"headerlink\" title=\"Crowds In A Polygon Soup: Next-Gen Path Planning\"></a>Crowds In A Polygon Soup: Next-Gen Path Planning</h2><p>Mikko Mononen 在 Recast &amp; Detour 中生成NavMesh的基本流程受到 GDC2006 上演讲<a href=\"http://gdcvault.com/play/1013192/Crowds-In-A-Polygon-Soup\" target=\"_blank\" rel=\"external\">《Crowds In A Polygon Soup: Next-Gen Path Planning》</a>的启发。</p>\n<ul>\n<li><p><strong>Session:  Crowds In A Polygon Soup: Next-Gen Path Planning</strong><br>By David Miles, David Miles, David Miles, David Miles</p>\n<ul>\n<li><a href=\"/files/About_NavMesh/GDC-06-038.mp3\">Session mp3</a></li>\n<li><a href=\"/files/About_NavMesh/gdc2006_miles_david_pathplanning.ppt\">Session ppt</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"谷阿莫带你十分钟看完-NavMesh-生成算法\"><a href=\"#谷阿莫带你十分钟看完-NavMesh-生成算法\" class=\"headerlink\" title=\"谷阿莫带你十分钟看完 NavMesh 生成算法\"></a>谷阿莫带你十分钟看完 NavMesh 生成算法</h2><p>没有时间看完上面资料的同学可以看下面这个《谷阿莫带你十分钟看完 NavMesh 生成算法》的小抄。</p>\n<p><img src=\"/images/About_NavMesh/Image[1].png\" alt=\"谷阿莫带你十分钟看完 NavMesh 生成算法\"></p>\n<p><a href=\"/2016/08/21/A_Quick_Introduction_to_NavMesh/\">谷阿莫带你十分钟看完 NavMesh 生成算法</a></p>\n","excerpt":"<p>这是一篇关于NavMesh的资料整理和总结笔记。整理了前段时间收集的NavMesh相关的资料和一个简单的算法描述。</p>\n<p><em>（文章出现的所有算法描述和资料均来源于互联网，绝无半点个人原创内容，请放心阅读。）</em></p>\n<h2 id=\"Recast-amp-Detour\"><a href=\"#Recast-amp-Detour\" class=\"headerlink\" title=\"Recast &amp; Detour\"></a>Recast &amp; Detour</h2><p>Recast &amp; Detour <a href=\"https://github.com/recastnavigation/recastnavigation\">GITHUB PAGE</a> 是一个开源的游戏寻路引擎，被包括Unity，UE4等游戏引擎采用。</p>\n<p><img src=\"/images/About_NavMesh/Image_RecastAndDetour.png\" alt=\"Recast &amp; Detour\"></p>","more":"<p>Recast &amp; Detour 包括了两部分，即 Recast 和 Detour。</p>\n<p>Recast 通过将输入的场景模型体素化生成相应的寻路网格。其大概包括三个步骤：1. 体素化模型；2. 分割联通区域； 3. 将区域简化为多边形</p>\n<p>Detour 通过使用 Recast 生成的 NavMesh 进行寻路，其包括了许多算法，根据不同路径平滑程度和寻路效率要求可做不同选择。</p>\n<p>该开源库的作者 Mikko Mononen 在 AiGameDev.com 有一个相关的介绍视频 <a href=\"http://aigamedev.com/insider/presentations/recast-teaser/\">Building and Traversing Navigation Meshes with Recast and Detour (Project Video)</a>。</p>\n<p>Mikko Mononen 在该文章 References 部分贴出了一系列相关的参考文献。</p>\n<ul>\n<li><strong>Conservative Voxelization</strong><br>Long Zhang, Wei Chen, David S. Ebert, Qunsheng Peng<br><a href=\"/files/About_NavMesh/P1_Conservative_voxelization.pdf\">PDF</a></li>\n</ul>\n<ul>\n<li><strong>Real-time Voxelization for Complex Polygonal Models</strong><br>Zhao Dong, Wei Chen, Hujun Bao, Hongxin Zhang, Qunsheng Peng<br><a href=\"/files/About_NavMesh/P2_Real-time_Voxelization_for_Complex_Models.pdf\">PDF</a></li>\n</ul>\n<ul>\n<li><strong>Single-pass GPU Solid Voxelization and Applications</strong><br>Elmar Eisemann, Xavier Décoret<br><a href=\"/files/About_NavMesh/P3_Single-Pass_GPU_Solid_Voxelization_for_Real-Time_Applications.pdf\">PDF</a></li>\n</ul>\n<ul>\n<li><strong>GPU Gems 2: Flow Simulation with Complex Boundaries</strong><br>Wei Li, Zhe Fan, Xiaoming Wei, Arie Kaufman<br><a href=\"/files/About_NavMesh/P4_GPU_Gems_2_Chapter_47_Flow_Simulation_with_Complex_Boundaries.pdf\">PDF</a></li>\n</ul>\n<ul>\n<li><strong>GPU Gems 3: Real-Time Simulation and Rendering of 3D Fluids</strong><br>Keenan Crane, Ignacio Llamas, Sarah Tariq<br><a href=\"/files/About_NavMesh/P5_GPU_Gems_3_Real-Time_Simulation_and_Rendering_of_3D_Fluids.pdf\">PDF</a></li>\n</ul>\n<ul>\n<li><strong>Way-Finder: guided tours through complex walkthrough models</strong><br>C. Andújar, P. Vázquez, M. Fairén<br><a href=\"/files/About_NavMesh/P6_Way-Finder_guided_tours_through_complex_walkthrough_models.pdf\">PDF</a></li>\n</ul>\n<ul>\n<li><p><strong>Volumetric Cell-and-Portal Generation</strong><br>Denis Haumont, Olivier Debeir, François Sillion<br><a href=\"/files/About_NavMesh/P7_Volumetric_cell-and-portal_generation.pdf\">PDF</a></p>\n</li>\n<li><p><strong>Skeleton Extraction of 3D Objects with Visible Repulsive Force</strong><br>Fu-Che Wu, Wan-Chun Ma, Ping-Chou Liou, Rung-Huei Liang, Ming Ouhyoung<br><a href=\"/files/About_NavMesh/P8_Skeleton_Extraction_of 3D_Objects_with_Visible_Repulsive_Force.pdf\">PDF</a></p>\n</li>\n<li><p><strong>Automated Static and Dynamic Obstacle Avoidance in Arbitrary 3D Polygonal Worlds</strong><br>Edited by Xing-Jian Jing<br><a href=\"/files/About_NavMesh/P9_Automated_Static_and Dynamic_ObstacleAvoidance_in_Arbitrary_3D_Polygonal_Worlds.pdf\">PDF</a></p>\n</li>\n</ul>\n<ul>\n<li><strong>A Navigation Graph for Real-time Crowd Animation on Multilayered and Uneven Terrain</strong><br>Julien Pettré, Jean-Paul Laumond, Daniel Thalmann<br><a href=\"/files/About_NavMesh/P10_A_navigation_graph_for_real-time_crowd_animation_on_multilayered_and_uneven_terrain.pdf\">PDF</a></li>\n</ul>\n<ul>\n<li><strong>Pedestrian Reactive Navigation for Crowd Simulation: a Predictive Approach</strong><br>Sébastien Paris, Julien Pettré, Stéphane Donikian<br><a href=\"/files/About_NavMesh/P11_Pedestrian_Reactive_Navigation_for_Crowd_Pedestrian_Reactive_Navigation_for_Crowd_Simulation_a_Predictive_Approach.pdf\">PDF</a></li>\n</ul>\n<h2 id=\"Study-Navigation-Mesh-Generation\"><a href=\"#Study-Navigation-Mesh-Generation\" class=\"headerlink\" title=\"Study: Navigation Mesh Generation\"></a>Study: Navigation Mesh Generation</h2><p>Stephen Pratt 在其项目 <a href=\"http://www.critterai.org/projects/nmgen_study/index.html\">《Study: Navigation Mesh Generation》</a> 中提供了一个 Java 版本的 Recast 实现，并在文档中对算法细节及参数进行了详细的讨论。</p>\n<p><img src=\"/images/About_NavMesh/Image_NavigationMeshGeneration.png\" alt=\"Study: Navigation Mesh Generation\"></p>\n<p>其中，</p>\n<ul>\n<li><a href=\"http://www.critterai.org/projects/nmgen_study/diffs.html\">《Differences Between NMGen and Recast》</a>描述了其实现与 Recast &amp; Detour 项目的异同之处；</li>\n<li><a href=\"http://www.critterai.org/projects/nmgen_study/config.html\">《Configuration Parameters》</a>罗列了算法中各参数对生成寻路网格数据的影响。</li>\n</ul>\n<h2 id=\"Crowds-In-A-Polygon-Soup-Next-Gen-Path-Planning\"><a href=\"#Crowds-In-A-Polygon-Soup-Next-Gen-Path-Planning\" class=\"headerlink\" title=\"Crowds In A Polygon Soup: Next-Gen Path Planning\"></a>Crowds In A Polygon Soup: Next-Gen Path Planning</h2><p>Mikko Mononen 在 Recast &amp; Detour 中生成NavMesh的基本流程受到 GDC2006 上演讲<a href=\"http://gdcvault.com/play/1013192/Crowds-In-A-Polygon-Soup\">《Crowds In A Polygon Soup: Next-Gen Path Planning》</a>的启发。</p>\n<ul>\n<li><p><strong>Session:  Crowds In A Polygon Soup: Next-Gen Path Planning</strong><br>By David Miles, David Miles, David Miles, David Miles</p>\n<ul>\n<li><a href=\"/files/About_NavMesh/GDC-06-038.mp3\">Session mp3</a></li>\n<li><a href=\"/files/About_NavMesh/gdc2006_miles_david_pathplanning.ppt\">Session ppt</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"谷阿莫带你十分钟看完-NavMesh-生成算法\"><a href=\"#谷阿莫带你十分钟看完-NavMesh-生成算法\" class=\"headerlink\" title=\"谷阿莫带你十分钟看完 NavMesh 生成算法\"></a>谷阿莫带你十分钟看完 NavMesh 生成算法</h2><p>没有时间看完上面资料的同学可以看下面这个《谷阿莫带你十分钟看完 NavMesh 生成算法》的小抄。</p>\n<p><img src=\"/images/About_NavMesh/Image[1].png\" alt=\"谷阿莫带你十分钟看完 NavMesh 生成算法\"></p>\n<p><a href=\"/2016/08/21/A_Quick_Introduction_to_NavMesh/\">谷阿莫带你十分钟看完 NavMesh 生成算法</a></p>"},{"title":"黑魔法之 iOS Flash ANE 打包","date":"2014-08-14T18:09:46.000Z","_content":"\nMA6-僵尸 使用Flash Air开发，故iOS SDK需包装一个Flash ANE版本。\n\n用到的环境有：Flash Builder 4.7、Xcode 5.1.1、iOS SDK 7.1\n\n## Flash Flex 项目 ##\n\n在Flash Buildder中建立一个 **Flex手机项目库** ，新建一个.as脚本，实现as的wrapper。\n下面给了个简化的项目示例，注意其中用于实现回调的onStatus和初始化函数NtUniSdk4Flash。\n\n <!-- more --> \n\n\tpackage com.netease.ntunisdk\n\t{\n\t\timport flash.events.EventDispatcher;\n\t\timport flash.events.StatusEvent;\n\t\timport flash.external.ExtensionContext;\n\t\n\t\tpublic class NtUniSdk4Flash extends EventDispatcher\n\t\t{\n\t\t\tprivate static var _instance:NtUniSdk4Flash;\n\t\t\tprivate var extContext:ExtensionContext;\n\t\t\n\t\t\tpublic function ntInit():void\n\t\t\t{\n\t\t\t\textContext.call( \"__NtSdkMgr_ntInit\" );\n\t\t\t}\n\t\t\n\t\t\tpublic static function get instance():NtUniSdk4Flash {\n\t\t\t\tif ( !_instance ) {\n\t\t\t\t\t_instance = new NtUniSdk4Flash( new SingletonEnforcer() );\n\t\t\t\t}\n\t\t\t\treturn _instance;\n\t\t\t}\n\n\t\t\tpublic function dispose():void { \n\t\t\t\textContext.dispose(); \n\t\t\t}\n\t\t\n\t\t\tprivate function onStatus( event:StatusEvent ):void {\n\t\t\t\tdispatchEvent( new SDKNotification(event.code, false, false) );\n\t\t\t}\n\t\t\n\t\t\n\t\t\t/**\n\t\t \t* Constructor. \n\t\t \t*/\t\t\n\t\t\tpublic function NtUniSdk4Flash( enforcer:SingletonEnforcer ) {\n\t\t\t\tsuper();\n\t\t\t\n\t\t\t\textContext = ExtensionContext.createExtensionContext( \"com.netease.ntunisdk.ios.ane\", \"\" );\n\t\t\t\n\t\t\t\tif ( !extContext ) {\n\t\t\t\t\tthrow new Error( \"iOS NtUniSdk native extension is not supported on this platform.\" );\n\t\t\t\t}\n\t\t\t\n\t\t\t\textContext.addEventListener( StatusEvent.STATUS, onStatus );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass SingletonEnforcer {\n\t\n\t}\n\t\n\t\n然后需要再建立一个extension.xml，示例再如下：\n\n\t<extension xmlns=\"http://ns.adobe.com/air/extension/3.1\"> \n    \t<id>com.netease.ntunisdk.ios.ane</id> \n    \t<versionNumber>0.0.1</versionNumber> \n    \t<platforms>  \n\t\t\t<platform name=\"iPhone-ARM\"> \n            \t<applicationDeployment> \n                \t<nativeLibrary>liblibNtUniSdk4Flash.a</nativeLibrary> \n                \t<initializer>ExtInitializer</initializer>\n            \t</applicationDeployment>\n        \t</platform>\n    \t</platforms> \n\t</extension>\n\t\n因为我们需要的只是iphone版本的ANE，所以只有iPhone-ARM一个平台。com.netease.ntunisdk.ios.ane和上面as代码中的ExtensionContext.createExtensionContext参数是对应的。\n\n然后，在菜单里，选择 项目 -> 构建项目，编译项目。如果你的构建项目事灰色的，那是打开了自动构建。把 项目 -> 自动构建 取消掉。\n\n这时候，可以等到 **产出1. 一个.swc文件** 。\n\n\n## Xcode 静态库项目 ##\n\n建立一个Coco Touch Static Library, 在Air SDK里找到 FlashRuntimeExtensions.h，添加到项目中。\n\n新建一个.m文件，下面给出项目简化版的示例：\n\n\t//\n\t//  libNtUniSdk4Flash.m\n\t//  libNtUniSdk4Flash\n\t//\n\t//  Created by Huang Quanyong on 14-8-7.\n\t//  Copyright (c) 2014年 Stupid Dumb Kids. All rights reserved.\n\t//\n\n\t#import \"FlashRuntimeExtensions.h\"\n\t#import \"UniHead.h\"\n\n\t#define STRING_BUFFER_SIZE 1024*128\n\n\t@interface __NtNotificationWrapper : NSObject\n\n\t@end\n\tstatic __NtNotificationWrapper *__inst = nil;\n\tstatic FREContext __context = NULL;\n\n\t@implementation __NtNotificationWrapper\n\n\t+ (void) initialize\n\t{\n    \tif (__inst) {\n        \treturn;\n    \t}\n    \n   \t\t__inst = [[__NtNotificationWrapper alloc] init];\n    \n    \t//初始化通知\n    \t[[NSNotificationCenter defaultCenter] addObserver:__inst selector:@selector(finishInitNotification:) name:NT_NOTIFICATION_FINISH_INIT object:nil];\n    \n    }\n\n\t//初始化完成处理\n\t- (void)finishInitNotification:(NSNotification *)notification\n\t{\n   \t\tNSString* str = NT_NOTIFICATION_FINISH_INIT;\n    \tconst uint8_t *code = (const uint8_t*) [str UTF8String];\n    \tFREDispatchStatusEventAsync(__context, code, code);\n    \tNSLog(@\"[NtUniSdk] Notification finishInit.\");\n\t}\n\n\t+ (void) doNothing{}\n\n\t@end\n\n\tFREObject __NtSdkMgr_ntInit(FREContext ctx, void* funcData, uint32_t argc, FREObject argv[])\n\t{\n    \tNSLog(@\"[NtUniSdk] __NtSdkMgr_ntInit\");\n    \t[__NtNotificationWrapper doNothing];\n    \t[NtSdkMgr ntInit];\n    \treturn NULL;\n\t}\n\t\n\t// InitNativeCode()\n\t//\n\t// An InitNativeCode function is necessary in the Android implementation of this extension.\n\t// Therefore, an analogous function is necessary in the iOS implementation to make\n\t// the ActionScript interface identical for all implementations.\n\t// However, the iOS implementation has nothing to do.\n\tFREObject InitNativeCode(FREContext ctx, void* funcData, uint32_t argc, FREObject argv[]) {\n    \n    \tNSLog(@\"Entering InitNativeCode()\");\n    \n    \t// Nothing to do.\n    \n    \tNSLog(@\"Exiting InitNativeCode()\");\n    \n    \treturn NULL;\n\t}\n\n\t// ContextInitializer()\n\t//\n\t// The context initializer is called when the runtime creates the extension context instance.\n\n\tvoid ContextInitializer(void* extData, const uint8_t* ctxType, FREContext ctx, uint32_t* numFunctionsToTest, const FRENamedFunction** functionsToSet) {\n    \n    \tNSLog(@\"Entering ContextInitializer()\");\n    \n    \t__context = ctx;\n    \n    \t*numFunctionsToTest = 22;\n    \tFRENamedFunction* func = (FRENamedFunction*) malloc(sizeof(FRENamedFunction) * *numFunctionsToTest);\n    \t\n    \t//Just for consistency with Android\n    \tfunc[0].name = (const uint8_t*) \"__NtSdkMgr_ntInit\";\n    \tfunc[0].functionData = NULL;\n    \tfunc[0].function = &__NtSdkMgr_ntInit;\n    \n    \t*functionsToSet = func;\n    \n    \tNSLog(@\"Exiting ContextInitializer()\");\n\t}\n\n\t// ContextFinalizer()\n\t//\n\t// The context finalizer is called when the extension's ActionScript code\n\t// calls the ExtensionContext instance's dispose() method.\n\t// If the AIR runtime garbage collector disposes of the ExtensionContext instance, the runtime also calls\n\t// ContextFinalizer().\n\n\tvoid ContextFinalizer(FREContext ctx) {\n    \n   \t \tNSLog(@\"Entering ContextFinalizer()\");\n    \n    \t// Nothing to clean up.\n    \n    \tNSLog(@\"Exiting ContextFinalizer()\");\n    \n    \treturn;\n\t}\n\n\t// ExtInitializer()\n\t//\n\t// The extension initializer is called the first time the ActionScript side of the extension\n\t// calls ExtensionContext.createExtensionContext() for any context.\n\n\tvoid ExtInitializer(void** extDataToSet, FREContextInitializer* ctxInitializerToSet, FREContextFinalizer* ctxFinalizerToSet) {\n    \n    \tNSLog(@\"Entering ExtInitializer()\");\n    \n    \t*extDataToSet = NULL;\n    \t*ctxInitializerToSet = &ContextInitializer;\n    \t*ctxFinalizerToSet = &ContextFinalizer;\n    \n    \tNSLog(@\"Exiting ExtInitializer()\");\n\t}\n\n\t// ExtFinalizer()\n\t//\n\t// The extension finalizer is called when the runtime unloads the extension. However, it is not always called.\n\n\tvoid ExtFinalizer(void* extData) {\n    \n    \tNSLog(@\"Entering ExtFinalizer()\");\n    \n    \t// Nothing to clean up.\n    \n    \tNSLog(@\"Exiting ExtFinalizer()\");\n    \treturn;\n\t}\n\t\n注意中间消息的回调实现，调用FREDispatchStatusEventAsync，会触发as里的onStatus。\n\n编译该项目，得到 **产出2.一个.a文件** ，即是extension.xml中的\n\n\t<nativeLibrary>liblibNtUniSdk4Flash.a</nativeLibrary> \n\t\n## 编译ANE ###\n\n编译ANE的过程简直就是黑魔法。\n\n建立一个platform.xml，写入库依赖连接信息，以iTools SDK为例。\n\n\t<platform xmlns=\"http://ns.adobe.com/air/extension/3.1\">\n    \t<description>An optional description.</description> \n    \t<copyright>2011 (optional)</copyright> \n    \t<sdkVersion>5.0.0</sdkVersion> \n    \t<linkerOptions> \n        \t<option>-ios_version_min 5.0</option>\n        \t<option>-framework AdSupport</option>\n        \t<option>-framework SystemConfiguration</option>\n        \t<option>-framework CFNetwork</option>\n        \t<option>-framework Security</option>\n        \t<option>-framework MobileCoreServices</option>\n        \t<option>-framework QuartzCore</option>\n        \t<option>-framework CoreTelephony</option>\n\n        \t<option>-framework StoreKit</option>\n        \t<option>-framework NtUniSdkiTools</option>\n        \n        \t<option>-lc /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS7.1.sdk/usr/lib/libz.dylib</option>\n    \t</linkerOptions> \n\t</platform>\n\n把产出1的.swc文件，后缀改为.zip，解压，得到catalog.xml和library.swf。\n\n建立一个文件夹，命名为iPhone-ARM，放入三个文件，上一步所得的catalog.xml和library.swf、产出1.的.a文件。\n\n新建一个目录，放入如下：\n\n+ 上文的iPhone-ARM文件夹\n+ 上文的platform.xml\n+ 上文的extension.xml\n+ 产出1.的NtUniSdk4Flash.swc\n+ developer_identity.p12 用于签名的证书，密码为111111 (没有的话，可是用Flash Builder生成，请看后面步骤)\n\n\n用以下指令编译ANE：\n\n\t\"/Applications/Adobe Flash Builder 4.7/sdks/4.6.0/bin/adt\" \\\n\t\t-package -storetype pkcs12 -keystore developer_identity.p12 -storepass 111111 \\\n\t\t-target com.netease.ntunisdk.ios.ane extension.xml -swc NtUniSdk4Flash.swc -platform iPhone-ARM -C iPhone-ARM  -platformoptions platform.xml  .\n\t\t\n然后，你就生成了一个可用的ANE文件。\n\n>没有developer_identity.p12证书\n\n>请新建一个Flex手机工程，在工程上点击右键，选择属性，并选择 Flex构建打包 -> Apple iOS，在右边选择 数字签名 -> 创建，即可创建一个可用的数字签名证书。\n\n\n\n","source":"_posts/Black_Magic_Flash_iOS_ANE.md","raw":"title: 黑魔法之 iOS Flash ANE 打包\ndate: 2014-08-15 02:09:46\ntags: [iOS,SDK,Flash,ANE]\n---\n\nMA6-僵尸 使用Flash Air开发，故iOS SDK需包装一个Flash ANE版本。\n\n用到的环境有：Flash Builder 4.7、Xcode 5.1.1、iOS SDK 7.1\n\n## Flash Flex 项目 ##\n\n在Flash Buildder中建立一个 **Flex手机项目库** ，新建一个.as脚本，实现as的wrapper。\n下面给了个简化的项目示例，注意其中用于实现回调的onStatus和初始化函数NtUniSdk4Flash。\n\n <!-- more --> \n\n\tpackage com.netease.ntunisdk\n\t{\n\t\timport flash.events.EventDispatcher;\n\t\timport flash.events.StatusEvent;\n\t\timport flash.external.ExtensionContext;\n\t\n\t\tpublic class NtUniSdk4Flash extends EventDispatcher\n\t\t{\n\t\t\tprivate static var _instance:NtUniSdk4Flash;\n\t\t\tprivate var extContext:ExtensionContext;\n\t\t\n\t\t\tpublic function ntInit():void\n\t\t\t{\n\t\t\t\textContext.call( \"__NtSdkMgr_ntInit\" );\n\t\t\t}\n\t\t\n\t\t\tpublic static function get instance():NtUniSdk4Flash {\n\t\t\t\tif ( !_instance ) {\n\t\t\t\t\t_instance = new NtUniSdk4Flash( new SingletonEnforcer() );\n\t\t\t\t}\n\t\t\t\treturn _instance;\n\t\t\t}\n\n\t\t\tpublic function dispose():void { \n\t\t\t\textContext.dispose(); \n\t\t\t}\n\t\t\n\t\t\tprivate function onStatus( event:StatusEvent ):void {\n\t\t\t\tdispatchEvent( new SDKNotification(event.code, false, false) );\n\t\t\t}\n\t\t\n\t\t\n\t\t\t/**\n\t\t \t* Constructor. \n\t\t \t*/\t\t\n\t\t\tpublic function NtUniSdk4Flash( enforcer:SingletonEnforcer ) {\n\t\t\t\tsuper();\n\t\t\t\n\t\t\t\textContext = ExtensionContext.createExtensionContext( \"com.netease.ntunisdk.ios.ane\", \"\" );\n\t\t\t\n\t\t\t\tif ( !extContext ) {\n\t\t\t\t\tthrow new Error( \"iOS NtUniSdk native extension is not supported on this platform.\" );\n\t\t\t\t}\n\t\t\t\n\t\t\t\textContext.addEventListener( StatusEvent.STATUS, onStatus );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass SingletonEnforcer {\n\t\n\t}\n\t\n\t\n然后需要再建立一个extension.xml，示例再如下：\n\n\t<extension xmlns=\"http://ns.adobe.com/air/extension/3.1\"> \n    \t<id>com.netease.ntunisdk.ios.ane</id> \n    \t<versionNumber>0.0.1</versionNumber> \n    \t<platforms>  \n\t\t\t<platform name=\"iPhone-ARM\"> \n            \t<applicationDeployment> \n                \t<nativeLibrary>liblibNtUniSdk4Flash.a</nativeLibrary> \n                \t<initializer>ExtInitializer</initializer>\n            \t</applicationDeployment>\n        \t</platform>\n    \t</platforms> \n\t</extension>\n\t\n因为我们需要的只是iphone版本的ANE，所以只有iPhone-ARM一个平台。com.netease.ntunisdk.ios.ane和上面as代码中的ExtensionContext.createExtensionContext参数是对应的。\n\n然后，在菜单里，选择 项目 -> 构建项目，编译项目。如果你的构建项目事灰色的，那是打开了自动构建。把 项目 -> 自动构建 取消掉。\n\n这时候，可以等到 **产出1. 一个.swc文件** 。\n\n\n## Xcode 静态库项目 ##\n\n建立一个Coco Touch Static Library, 在Air SDK里找到 FlashRuntimeExtensions.h，添加到项目中。\n\n新建一个.m文件，下面给出项目简化版的示例：\n\n\t//\n\t//  libNtUniSdk4Flash.m\n\t//  libNtUniSdk4Flash\n\t//\n\t//  Created by Huang Quanyong on 14-8-7.\n\t//  Copyright (c) 2014年 Stupid Dumb Kids. All rights reserved.\n\t//\n\n\t#import \"FlashRuntimeExtensions.h\"\n\t#import \"UniHead.h\"\n\n\t#define STRING_BUFFER_SIZE 1024*128\n\n\t@interface __NtNotificationWrapper : NSObject\n\n\t@end\n\tstatic __NtNotificationWrapper *__inst = nil;\n\tstatic FREContext __context = NULL;\n\n\t@implementation __NtNotificationWrapper\n\n\t+ (void) initialize\n\t{\n    \tif (__inst) {\n        \treturn;\n    \t}\n    \n   \t\t__inst = [[__NtNotificationWrapper alloc] init];\n    \n    \t//初始化通知\n    \t[[NSNotificationCenter defaultCenter] addObserver:__inst selector:@selector(finishInitNotification:) name:NT_NOTIFICATION_FINISH_INIT object:nil];\n    \n    }\n\n\t//初始化完成处理\n\t- (void)finishInitNotification:(NSNotification *)notification\n\t{\n   \t\tNSString* str = NT_NOTIFICATION_FINISH_INIT;\n    \tconst uint8_t *code = (const uint8_t*) [str UTF8String];\n    \tFREDispatchStatusEventAsync(__context, code, code);\n    \tNSLog(@\"[NtUniSdk] Notification finishInit.\");\n\t}\n\n\t+ (void) doNothing{}\n\n\t@end\n\n\tFREObject __NtSdkMgr_ntInit(FREContext ctx, void* funcData, uint32_t argc, FREObject argv[])\n\t{\n    \tNSLog(@\"[NtUniSdk] __NtSdkMgr_ntInit\");\n    \t[__NtNotificationWrapper doNothing];\n    \t[NtSdkMgr ntInit];\n    \treturn NULL;\n\t}\n\t\n\t// InitNativeCode()\n\t//\n\t// An InitNativeCode function is necessary in the Android implementation of this extension.\n\t// Therefore, an analogous function is necessary in the iOS implementation to make\n\t// the ActionScript interface identical for all implementations.\n\t// However, the iOS implementation has nothing to do.\n\tFREObject InitNativeCode(FREContext ctx, void* funcData, uint32_t argc, FREObject argv[]) {\n    \n    \tNSLog(@\"Entering InitNativeCode()\");\n    \n    \t// Nothing to do.\n    \n    \tNSLog(@\"Exiting InitNativeCode()\");\n    \n    \treturn NULL;\n\t}\n\n\t// ContextInitializer()\n\t//\n\t// The context initializer is called when the runtime creates the extension context instance.\n\n\tvoid ContextInitializer(void* extData, const uint8_t* ctxType, FREContext ctx, uint32_t* numFunctionsToTest, const FRENamedFunction** functionsToSet) {\n    \n    \tNSLog(@\"Entering ContextInitializer()\");\n    \n    \t__context = ctx;\n    \n    \t*numFunctionsToTest = 22;\n    \tFRENamedFunction* func = (FRENamedFunction*) malloc(sizeof(FRENamedFunction) * *numFunctionsToTest);\n    \t\n    \t//Just for consistency with Android\n    \tfunc[0].name = (const uint8_t*) \"__NtSdkMgr_ntInit\";\n    \tfunc[0].functionData = NULL;\n    \tfunc[0].function = &__NtSdkMgr_ntInit;\n    \n    \t*functionsToSet = func;\n    \n    \tNSLog(@\"Exiting ContextInitializer()\");\n\t}\n\n\t// ContextFinalizer()\n\t//\n\t// The context finalizer is called when the extension's ActionScript code\n\t// calls the ExtensionContext instance's dispose() method.\n\t// If the AIR runtime garbage collector disposes of the ExtensionContext instance, the runtime also calls\n\t// ContextFinalizer().\n\n\tvoid ContextFinalizer(FREContext ctx) {\n    \n   \t \tNSLog(@\"Entering ContextFinalizer()\");\n    \n    \t// Nothing to clean up.\n    \n    \tNSLog(@\"Exiting ContextFinalizer()\");\n    \n    \treturn;\n\t}\n\n\t// ExtInitializer()\n\t//\n\t// The extension initializer is called the first time the ActionScript side of the extension\n\t// calls ExtensionContext.createExtensionContext() for any context.\n\n\tvoid ExtInitializer(void** extDataToSet, FREContextInitializer* ctxInitializerToSet, FREContextFinalizer* ctxFinalizerToSet) {\n    \n    \tNSLog(@\"Entering ExtInitializer()\");\n    \n    \t*extDataToSet = NULL;\n    \t*ctxInitializerToSet = &ContextInitializer;\n    \t*ctxFinalizerToSet = &ContextFinalizer;\n    \n    \tNSLog(@\"Exiting ExtInitializer()\");\n\t}\n\n\t// ExtFinalizer()\n\t//\n\t// The extension finalizer is called when the runtime unloads the extension. However, it is not always called.\n\n\tvoid ExtFinalizer(void* extData) {\n    \n    \tNSLog(@\"Entering ExtFinalizer()\");\n    \n    \t// Nothing to clean up.\n    \n    \tNSLog(@\"Exiting ExtFinalizer()\");\n    \treturn;\n\t}\n\t\n注意中间消息的回调实现，调用FREDispatchStatusEventAsync，会触发as里的onStatus。\n\n编译该项目，得到 **产出2.一个.a文件** ，即是extension.xml中的\n\n\t<nativeLibrary>liblibNtUniSdk4Flash.a</nativeLibrary> \n\t\n## 编译ANE ###\n\n编译ANE的过程简直就是黑魔法。\n\n建立一个platform.xml，写入库依赖连接信息，以iTools SDK为例。\n\n\t<platform xmlns=\"http://ns.adobe.com/air/extension/3.1\">\n    \t<description>An optional description.</description> \n    \t<copyright>2011 (optional)</copyright> \n    \t<sdkVersion>5.0.0</sdkVersion> \n    \t<linkerOptions> \n        \t<option>-ios_version_min 5.0</option>\n        \t<option>-framework AdSupport</option>\n        \t<option>-framework SystemConfiguration</option>\n        \t<option>-framework CFNetwork</option>\n        \t<option>-framework Security</option>\n        \t<option>-framework MobileCoreServices</option>\n        \t<option>-framework QuartzCore</option>\n        \t<option>-framework CoreTelephony</option>\n\n        \t<option>-framework StoreKit</option>\n        \t<option>-framework NtUniSdkiTools</option>\n        \n        \t<option>-lc /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS7.1.sdk/usr/lib/libz.dylib</option>\n    \t</linkerOptions> \n\t</platform>\n\n把产出1的.swc文件，后缀改为.zip，解压，得到catalog.xml和library.swf。\n\n建立一个文件夹，命名为iPhone-ARM，放入三个文件，上一步所得的catalog.xml和library.swf、产出1.的.a文件。\n\n新建一个目录，放入如下：\n\n+ 上文的iPhone-ARM文件夹\n+ 上文的platform.xml\n+ 上文的extension.xml\n+ 产出1.的NtUniSdk4Flash.swc\n+ developer_identity.p12 用于签名的证书，密码为111111 (没有的话，可是用Flash Builder生成，请看后面步骤)\n\n\n用以下指令编译ANE：\n\n\t\"/Applications/Adobe Flash Builder 4.7/sdks/4.6.0/bin/adt\" \\\n\t\t-package -storetype pkcs12 -keystore developer_identity.p12 -storepass 111111 \\\n\t\t-target com.netease.ntunisdk.ios.ane extension.xml -swc NtUniSdk4Flash.swc -platform iPhone-ARM -C iPhone-ARM  -platformoptions platform.xml  .\n\t\t\n然后，你就生成了一个可用的ANE文件。\n\n>没有developer_identity.p12证书\n\n>请新建一个Flex手机工程，在工程上点击右键，选择属性，并选择 Flex构建打包 -> Apple iOS，在右边选择 数字签名 -> 创建，即可创建一个可用的数字签名证书。\n\n\n\n","slug":"Black_Magic_Flash_iOS_ANE","published":1,"updated":"2016-08-08T11:42:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civzfqil3000af66oc4civkh5","content":"<p>MA6-僵尸 使用Flash Air开发，故iOS SDK需包装一个Flash ANE版本。</p>\n<p>用到的环境有：Flash Builder 4.7、Xcode 5.1.1、iOS SDK 7.1</p>\n<h2 id=\"Flash-Flex-项目\"><a href=\"#Flash-Flex-项目\" class=\"headerlink\" title=\"Flash Flex 项目\"></a>Flash Flex 项目</h2><p>在Flash Buildder中建立一个 <strong>Flex手机项目库</strong> ，新建一个.as脚本，实现as的wrapper。<br>下面给了个简化的项目示例，注意其中用于实现回调的onStatus和初始化函数NtUniSdk4Flash。</p>\n <a id=\"more\"></a> \n<pre><code>package com.netease.ntunisdk\n{\n    import flash.events.EventDispatcher;\n    import flash.events.StatusEvent;\n    import flash.external.ExtensionContext;\n\n    public class NtUniSdk4Flash extends EventDispatcher\n    {\n        private static var _instance:NtUniSdk4Flash;\n        private var extContext:ExtensionContext;\n\n        public function ntInit():void\n        {\n            extContext.call( &quot;__NtSdkMgr_ntInit&quot; );\n        }\n\n        public static function get instance():NtUniSdk4Flash {\n            if ( !_instance ) {\n                _instance = new NtUniSdk4Flash( new SingletonEnforcer() );\n            }\n            return _instance;\n        }\n\n        public function dispose():void { \n            extContext.dispose(); \n        }\n\n        private function onStatus( event:StatusEvent ):void {\n            dispatchEvent( new SDKNotification(event.code, false, false) );\n        }\n\n\n        /**\n         * Constructor. \n         */        \n        public function NtUniSdk4Flash( enforcer:SingletonEnforcer ) {\n            super();\n\n            extContext = ExtensionContext.createExtensionContext( &quot;com.netease.ntunisdk.ios.ane&quot;, &quot;&quot; );\n\n            if ( !extContext ) {\n                throw new Error( &quot;iOS NtUniSdk native extension is not supported on this platform.&quot; );\n            }\n\n            extContext.addEventListener( StatusEvent.STATUS, onStatus );\n        }\n    }\n}\n\nclass SingletonEnforcer {\n\n}\n</code></pre><p>然后需要再建立一个extension.xml，示例再如下：</p>\n<pre><code>&lt;extension xmlns=&quot;http://ns.adobe.com/air/extension/3.1&quot;&gt; \n    &lt;id&gt;com.netease.ntunisdk.ios.ane&lt;/id&gt; \n    &lt;versionNumber&gt;0.0.1&lt;/versionNumber&gt; \n    &lt;platforms&gt;  \n        &lt;platform name=&quot;iPhone-ARM&quot;&gt; \n            &lt;applicationDeployment&gt; \n                &lt;nativeLibrary&gt;liblibNtUniSdk4Flash.a&lt;/nativeLibrary&gt; \n                &lt;initializer&gt;ExtInitializer&lt;/initializer&gt;\n            &lt;/applicationDeployment&gt;\n        &lt;/platform&gt;\n    &lt;/platforms&gt; \n&lt;/extension&gt;\n</code></pre><p>因为我们需要的只是iphone版本的ANE，所以只有iPhone-ARM一个平台。com.netease.ntunisdk.ios.ane和上面as代码中的ExtensionContext.createExtensionContext参数是对应的。</p>\n<p>然后，在菜单里，选择 项目 -&gt; 构建项目，编译项目。如果你的构建项目事灰色的，那是打开了自动构建。把 项目 -&gt; 自动构建 取消掉。</p>\n<p>这时候，可以等到 <strong>产出1. 一个.swc文件</strong> 。</p>\n<h2 id=\"Xcode-静态库项目\"><a href=\"#Xcode-静态库项目\" class=\"headerlink\" title=\"Xcode 静态库项目\"></a>Xcode 静态库项目</h2><p>建立一个Coco Touch Static Library, 在Air SDK里找到 FlashRuntimeExtensions.h，添加到项目中。</p>\n<p>新建一个.m文件，下面给出项目简化版的示例：</p>\n<pre><code>//\n//  libNtUniSdk4Flash.m\n//  libNtUniSdk4Flash\n//\n//  Created by Huang Quanyong on 14-8-7.\n//  Copyright (c) 2014年 Stupid Dumb Kids. All rights reserved.\n//\n\n#import &quot;FlashRuntimeExtensions.h&quot;\n#import &quot;UniHead.h&quot;\n\n#define STRING_BUFFER_SIZE 1024*128\n\n@interface __NtNotificationWrapper : NSObject\n\n@end\nstatic __NtNotificationWrapper *__inst = nil;\nstatic FREContext __context = NULL;\n\n@implementation __NtNotificationWrapper\n\n+ (void) initialize\n{\n    if (__inst) {\n        return;\n    }\n\n       __inst = [[__NtNotificationWrapper alloc] init];\n\n    //初始化通知\n    [[NSNotificationCenter defaultCenter] addObserver:__inst selector:@selector(finishInitNotification:) name:NT_NOTIFICATION_FINISH_INIT object:nil];\n\n}\n\n//初始化完成处理\n- (void)finishInitNotification:(NSNotification *)notification\n{\n       NSString* str = NT_NOTIFICATION_FINISH_INIT;\n    const uint8_t *code = (const uint8_t*) [str UTF8String];\n    FREDispatchStatusEventAsync(__context, code, code);\n    NSLog(@&quot;[NtUniSdk] Notification finishInit.&quot;);\n}\n\n+ (void) doNothing{}\n\n@end\n\nFREObject __NtSdkMgr_ntInit(FREContext ctx, void* funcData, uint32_t argc, FREObject argv[])\n{\n    NSLog(@&quot;[NtUniSdk] __NtSdkMgr_ntInit&quot;);\n    [__NtNotificationWrapper doNothing];\n    [NtSdkMgr ntInit];\n    return NULL;\n}\n\n// InitNativeCode()\n//\n// An InitNativeCode function is necessary in the Android implementation of this extension.\n// Therefore, an analogous function is necessary in the iOS implementation to make\n// the ActionScript interface identical for all implementations.\n// However, the iOS implementation has nothing to do.\nFREObject InitNativeCode(FREContext ctx, void* funcData, uint32_t argc, FREObject argv[]) {\n\n    NSLog(@&quot;Entering InitNativeCode()&quot;);\n\n    // Nothing to do.\n\n    NSLog(@&quot;Exiting InitNativeCode()&quot;);\n\n    return NULL;\n}\n\n// ContextInitializer()\n//\n// The context initializer is called when the runtime creates the extension context instance.\n\nvoid ContextInitializer(void* extData, const uint8_t* ctxType, FREContext ctx, uint32_t* numFunctionsToTest, const FRENamedFunction** functionsToSet) {\n\n    NSLog(@&quot;Entering ContextInitializer()&quot;);\n\n    __context = ctx;\n\n    *numFunctionsToTest = 22;\n    FRENamedFunction* func = (FRENamedFunction*) malloc(sizeof(FRENamedFunction) * *numFunctionsToTest);\n\n    //Just for consistency with Android\n    func[0].name = (const uint8_t*) &quot;__NtSdkMgr_ntInit&quot;;\n    func[0].functionData = NULL;\n    func[0].function = &amp;__NtSdkMgr_ntInit;\n\n    *functionsToSet = func;\n\n    NSLog(@&quot;Exiting ContextInitializer()&quot;);\n}\n\n// ContextFinalizer()\n//\n// The context finalizer is called when the extension&apos;s ActionScript code\n// calls the ExtensionContext instance&apos;s dispose() method.\n// If the AIR runtime garbage collector disposes of the ExtensionContext instance, the runtime also calls\n// ContextFinalizer().\n\nvoid ContextFinalizer(FREContext ctx) {\n\n        NSLog(@&quot;Entering ContextFinalizer()&quot;);\n\n    // Nothing to clean up.\n\n    NSLog(@&quot;Exiting ContextFinalizer()&quot;);\n\n    return;\n}\n\n// ExtInitializer()\n//\n// The extension initializer is called the first time the ActionScript side of the extension\n// calls ExtensionContext.createExtensionContext() for any context.\n\nvoid ExtInitializer(void** extDataToSet, FREContextInitializer* ctxInitializerToSet, FREContextFinalizer* ctxFinalizerToSet) {\n\n    NSLog(@&quot;Entering ExtInitializer()&quot;);\n\n    *extDataToSet = NULL;\n    *ctxInitializerToSet = &amp;ContextInitializer;\n    *ctxFinalizerToSet = &amp;ContextFinalizer;\n\n    NSLog(@&quot;Exiting ExtInitializer()&quot;);\n}\n\n// ExtFinalizer()\n//\n// The extension finalizer is called when the runtime unloads the extension. However, it is not always called.\n\nvoid ExtFinalizer(void* extData) {\n\n    NSLog(@&quot;Entering ExtFinalizer()&quot;);\n\n    // Nothing to clean up.\n\n    NSLog(@&quot;Exiting ExtFinalizer()&quot;);\n    return;\n}\n</code></pre><p>注意中间消息的回调实现，调用FREDispatchStatusEventAsync，会触发as里的onStatus。</p>\n<p>编译该项目，得到 <strong>产出2.一个.a文件</strong> ，即是extension.xml中的</p>\n<pre><code>&lt;nativeLibrary&gt;liblibNtUniSdk4Flash.a&lt;/nativeLibrary&gt; \n</code></pre><h2 id=\"编译ANE\"><a href=\"#编译ANE\" class=\"headerlink\" title=\"编译ANE\"></a>编译ANE</h2><p>编译ANE的过程简直就是黑魔法。</p>\n<p>建立一个platform.xml，写入库依赖连接信息，以iTools SDK为例。</p>\n<pre><code>&lt;platform xmlns=&quot;http://ns.adobe.com/air/extension/3.1&quot;&gt;\n    &lt;description&gt;An optional description.&lt;/description&gt; \n    &lt;copyright&gt;2011 (optional)&lt;/copyright&gt; \n    &lt;sdkVersion&gt;5.0.0&lt;/sdkVersion&gt; \n    &lt;linkerOptions&gt; \n        &lt;option&gt;-ios_version_min 5.0&lt;/option&gt;\n        &lt;option&gt;-framework AdSupport&lt;/option&gt;\n        &lt;option&gt;-framework SystemConfiguration&lt;/option&gt;\n        &lt;option&gt;-framework CFNetwork&lt;/option&gt;\n        &lt;option&gt;-framework Security&lt;/option&gt;\n        &lt;option&gt;-framework MobileCoreServices&lt;/option&gt;\n        &lt;option&gt;-framework QuartzCore&lt;/option&gt;\n        &lt;option&gt;-framework CoreTelephony&lt;/option&gt;\n\n        &lt;option&gt;-framework StoreKit&lt;/option&gt;\n        &lt;option&gt;-framework NtUniSdkiTools&lt;/option&gt;\n\n        &lt;option&gt;-lc /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS7.1.sdk/usr/lib/libz.dylib&lt;/option&gt;\n    &lt;/linkerOptions&gt; \n&lt;/platform&gt;\n</code></pre><p>把产出1的.swc文件，后缀改为.zip，解压，得到catalog.xml和library.swf。</p>\n<p>建立一个文件夹，命名为iPhone-ARM，放入三个文件，上一步所得的catalog.xml和library.swf、产出1.的.a文件。</p>\n<p>新建一个目录，放入如下：</p>\n<ul>\n<li>上文的iPhone-ARM文件夹</li>\n<li>上文的platform.xml</li>\n<li>上文的extension.xml</li>\n<li>产出1.的NtUniSdk4Flash.swc</li>\n<li>developer_identity.p12 用于签名的证书，密码为111111 (没有的话，可是用Flash Builder生成，请看后面步骤)</li>\n</ul>\n<p>用以下指令编译ANE：</p>\n<pre><code>&quot;/Applications/Adobe Flash Builder 4.7/sdks/4.6.0/bin/adt&quot; \\\n    -package -storetype pkcs12 -keystore developer_identity.p12 -storepass 111111 \\\n    -target com.netease.ntunisdk.ios.ane extension.xml -swc NtUniSdk4Flash.swc -platform iPhone-ARM -C iPhone-ARM  -platformoptions platform.xml  .\n</code></pre><p>然后，你就生成了一个可用的ANE文件。</p>\n<blockquote>\n<p>没有developer_identity.p12证书</p>\n<p>请新建一个Flex手机工程，在工程上点击右键，选择属性，并选择 Flex构建打包 -&gt; Apple iOS，在右边选择 数字签名 -&gt; 创建，即可创建一个可用的数字签名证书。</p>\n</blockquote>\n","excerpt":"<p>MA6-僵尸 使用Flash Air开发，故iOS SDK需包装一个Flash ANE版本。</p>\n<p>用到的环境有：Flash Builder 4.7、Xcode 5.1.1、iOS SDK 7.1</p>\n<h2 id=\"Flash-Flex-项目\"><a href=\"#Flash-Flex-项目\" class=\"headerlink\" title=\"Flash Flex 项目\"></a>Flash Flex 项目</h2><p>在Flash Buildder中建立一个 <strong>Flex手机项目库</strong> ，新建一个.as脚本，实现as的wrapper。<br>下面给了个简化的项目示例，注意其中用于实现回调的onStatus和初始化函数NtUniSdk4Flash。</p>","more":"<pre><code>package com.netease.ntunisdk\n{\n    import flash.events.EventDispatcher;\n    import flash.events.StatusEvent;\n    import flash.external.ExtensionContext;\n\n    public class NtUniSdk4Flash extends EventDispatcher\n    {\n        private static var _instance:NtUniSdk4Flash;\n        private var extContext:ExtensionContext;\n\n        public function ntInit():void\n        {\n            extContext.call( &quot;__NtSdkMgr_ntInit&quot; );\n        }\n\n        public static function get instance():NtUniSdk4Flash {\n            if ( !_instance ) {\n                _instance = new NtUniSdk4Flash( new SingletonEnforcer() );\n            }\n            return _instance;\n        }\n\n        public function dispose():void { \n            extContext.dispose(); \n        }\n\n        private function onStatus( event:StatusEvent ):void {\n            dispatchEvent( new SDKNotification(event.code, false, false) );\n        }\n\n\n        /**\n         * Constructor. \n         */        \n        public function NtUniSdk4Flash( enforcer:SingletonEnforcer ) {\n            super();\n\n            extContext = ExtensionContext.createExtensionContext( &quot;com.netease.ntunisdk.ios.ane&quot;, &quot;&quot; );\n\n            if ( !extContext ) {\n                throw new Error( &quot;iOS NtUniSdk native extension is not supported on this platform.&quot; );\n            }\n\n            extContext.addEventListener( StatusEvent.STATUS, onStatus );\n        }\n    }\n}\n\nclass SingletonEnforcer {\n\n}\n</code></pre><p>然后需要再建立一个extension.xml，示例再如下：</p>\n<pre><code>&lt;extension xmlns=&quot;http://ns.adobe.com/air/extension/3.1&quot;&gt; \n    &lt;id&gt;com.netease.ntunisdk.ios.ane&lt;/id&gt; \n    &lt;versionNumber&gt;0.0.1&lt;/versionNumber&gt; \n    &lt;platforms&gt;  \n        &lt;platform name=&quot;iPhone-ARM&quot;&gt; \n            &lt;applicationDeployment&gt; \n                &lt;nativeLibrary&gt;liblibNtUniSdk4Flash.a&lt;/nativeLibrary&gt; \n                &lt;initializer&gt;ExtInitializer&lt;/initializer&gt;\n            &lt;/applicationDeployment&gt;\n        &lt;/platform&gt;\n    &lt;/platforms&gt; \n&lt;/extension&gt;\n</code></pre><p>因为我们需要的只是iphone版本的ANE，所以只有iPhone-ARM一个平台。com.netease.ntunisdk.ios.ane和上面as代码中的ExtensionContext.createExtensionContext参数是对应的。</p>\n<p>然后，在菜单里，选择 项目 -&gt; 构建项目，编译项目。如果你的构建项目事灰色的，那是打开了自动构建。把 项目 -&gt; 自动构建 取消掉。</p>\n<p>这时候，可以等到 <strong>产出1. 一个.swc文件</strong> 。</p>\n<h2 id=\"Xcode-静态库项目\"><a href=\"#Xcode-静态库项目\" class=\"headerlink\" title=\"Xcode 静态库项目\"></a>Xcode 静态库项目</h2><p>建立一个Coco Touch Static Library, 在Air SDK里找到 FlashRuntimeExtensions.h，添加到项目中。</p>\n<p>新建一个.m文件，下面给出项目简化版的示例：</p>\n<pre><code>//\n//  libNtUniSdk4Flash.m\n//  libNtUniSdk4Flash\n//\n//  Created by Huang Quanyong on 14-8-7.\n//  Copyright (c) 2014年 Stupid Dumb Kids. All rights reserved.\n//\n\n#import &quot;FlashRuntimeExtensions.h&quot;\n#import &quot;UniHead.h&quot;\n\n#define STRING_BUFFER_SIZE 1024*128\n\n@interface __NtNotificationWrapper : NSObject\n\n@end\nstatic __NtNotificationWrapper *__inst = nil;\nstatic FREContext __context = NULL;\n\n@implementation __NtNotificationWrapper\n\n+ (void) initialize\n{\n    if (__inst) {\n        return;\n    }\n\n       __inst = [[__NtNotificationWrapper alloc] init];\n\n    //初始化通知\n    [[NSNotificationCenter defaultCenter] addObserver:__inst selector:@selector(finishInitNotification:) name:NT_NOTIFICATION_FINISH_INIT object:nil];\n\n}\n\n//初始化完成处理\n- (void)finishInitNotification:(NSNotification *)notification\n{\n       NSString* str = NT_NOTIFICATION_FINISH_INIT;\n    const uint8_t *code = (const uint8_t*) [str UTF8String];\n    FREDispatchStatusEventAsync(__context, code, code);\n    NSLog(@&quot;[NtUniSdk] Notification finishInit.&quot;);\n}\n\n+ (void) doNothing{}\n\n@end\n\nFREObject __NtSdkMgr_ntInit(FREContext ctx, void* funcData, uint32_t argc, FREObject argv[])\n{\n    NSLog(@&quot;[NtUniSdk] __NtSdkMgr_ntInit&quot;);\n    [__NtNotificationWrapper doNothing];\n    [NtSdkMgr ntInit];\n    return NULL;\n}\n\n// InitNativeCode()\n//\n// An InitNativeCode function is necessary in the Android implementation of this extension.\n// Therefore, an analogous function is necessary in the iOS implementation to make\n// the ActionScript interface identical for all implementations.\n// However, the iOS implementation has nothing to do.\nFREObject InitNativeCode(FREContext ctx, void* funcData, uint32_t argc, FREObject argv[]) {\n\n    NSLog(@&quot;Entering InitNativeCode()&quot;);\n\n    // Nothing to do.\n\n    NSLog(@&quot;Exiting InitNativeCode()&quot;);\n\n    return NULL;\n}\n\n// ContextInitializer()\n//\n// The context initializer is called when the runtime creates the extension context instance.\n\nvoid ContextInitializer(void* extData, const uint8_t* ctxType, FREContext ctx, uint32_t* numFunctionsToTest, const FRENamedFunction** functionsToSet) {\n\n    NSLog(@&quot;Entering ContextInitializer()&quot;);\n\n    __context = ctx;\n\n    *numFunctionsToTest = 22;\n    FRENamedFunction* func = (FRENamedFunction*) malloc(sizeof(FRENamedFunction) * *numFunctionsToTest);\n\n    //Just for consistency with Android\n    func[0].name = (const uint8_t*) &quot;__NtSdkMgr_ntInit&quot;;\n    func[0].functionData = NULL;\n    func[0].function = &amp;__NtSdkMgr_ntInit;\n\n    *functionsToSet = func;\n\n    NSLog(@&quot;Exiting ContextInitializer()&quot;);\n}\n\n// ContextFinalizer()\n//\n// The context finalizer is called when the extension&apos;s ActionScript code\n// calls the ExtensionContext instance&apos;s dispose() method.\n// If the AIR runtime garbage collector disposes of the ExtensionContext instance, the runtime also calls\n// ContextFinalizer().\n\nvoid ContextFinalizer(FREContext ctx) {\n\n        NSLog(@&quot;Entering ContextFinalizer()&quot;);\n\n    // Nothing to clean up.\n\n    NSLog(@&quot;Exiting ContextFinalizer()&quot;);\n\n    return;\n}\n\n// ExtInitializer()\n//\n// The extension initializer is called the first time the ActionScript side of the extension\n// calls ExtensionContext.createExtensionContext() for any context.\n\nvoid ExtInitializer(void** extDataToSet, FREContextInitializer* ctxInitializerToSet, FREContextFinalizer* ctxFinalizerToSet) {\n\n    NSLog(@&quot;Entering ExtInitializer()&quot;);\n\n    *extDataToSet = NULL;\n    *ctxInitializerToSet = &amp;ContextInitializer;\n    *ctxFinalizerToSet = &amp;ContextFinalizer;\n\n    NSLog(@&quot;Exiting ExtInitializer()&quot;);\n}\n\n// ExtFinalizer()\n//\n// The extension finalizer is called when the runtime unloads the extension. However, it is not always called.\n\nvoid ExtFinalizer(void* extData) {\n\n    NSLog(@&quot;Entering ExtFinalizer()&quot;);\n\n    // Nothing to clean up.\n\n    NSLog(@&quot;Exiting ExtFinalizer()&quot;);\n    return;\n}\n</code></pre><p>注意中间消息的回调实现，调用FREDispatchStatusEventAsync，会触发as里的onStatus。</p>\n<p>编译该项目，得到 <strong>产出2.一个.a文件</strong> ，即是extension.xml中的</p>\n<pre><code>&lt;nativeLibrary&gt;liblibNtUniSdk4Flash.a&lt;/nativeLibrary&gt; \n</code></pre><h2 id=\"编译ANE\"><a href=\"#编译ANE\" class=\"headerlink\" title=\"编译ANE\"></a>编译ANE</h2><p>编译ANE的过程简直就是黑魔法。</p>\n<p>建立一个platform.xml，写入库依赖连接信息，以iTools SDK为例。</p>\n<pre><code>&lt;platform xmlns=&quot;http://ns.adobe.com/air/extension/3.1&quot;&gt;\n    &lt;description&gt;An optional description.&lt;/description&gt; \n    &lt;copyright&gt;2011 (optional)&lt;/copyright&gt; \n    &lt;sdkVersion&gt;5.0.0&lt;/sdkVersion&gt; \n    &lt;linkerOptions&gt; \n        &lt;option&gt;-ios_version_min 5.0&lt;/option&gt;\n        &lt;option&gt;-framework AdSupport&lt;/option&gt;\n        &lt;option&gt;-framework SystemConfiguration&lt;/option&gt;\n        &lt;option&gt;-framework CFNetwork&lt;/option&gt;\n        &lt;option&gt;-framework Security&lt;/option&gt;\n        &lt;option&gt;-framework MobileCoreServices&lt;/option&gt;\n        &lt;option&gt;-framework QuartzCore&lt;/option&gt;\n        &lt;option&gt;-framework CoreTelephony&lt;/option&gt;\n\n        &lt;option&gt;-framework StoreKit&lt;/option&gt;\n        &lt;option&gt;-framework NtUniSdkiTools&lt;/option&gt;\n\n        &lt;option&gt;-lc /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS7.1.sdk/usr/lib/libz.dylib&lt;/option&gt;\n    &lt;/linkerOptions&gt; \n&lt;/platform&gt;\n</code></pre><p>把产出1的.swc文件，后缀改为.zip，解压，得到catalog.xml和library.swf。</p>\n<p>建立一个文件夹，命名为iPhone-ARM，放入三个文件，上一步所得的catalog.xml和library.swf、产出1.的.a文件。</p>\n<p>新建一个目录，放入如下：</p>\n<ul>\n<li>上文的iPhone-ARM文件夹</li>\n<li>上文的platform.xml</li>\n<li>上文的extension.xml</li>\n<li>产出1.的NtUniSdk4Flash.swc</li>\n<li>developer_identity.p12 用于签名的证书，密码为111111 (没有的话，可是用Flash Builder生成，请看后面步骤)</li>\n</ul>\n<p>用以下指令编译ANE：</p>\n<pre><code>&quot;/Applications/Adobe Flash Builder 4.7/sdks/4.6.0/bin/adt&quot; \\\n    -package -storetype pkcs12 -keystore developer_identity.p12 -storepass 111111 \\\n    -target com.netease.ntunisdk.ios.ane extension.xml -swc NtUniSdk4Flash.swc -platform iPhone-ARM -C iPhone-ARM  -platformoptions platform.xml  .\n</code></pre><p>然后，你就生成了一个可用的ANE文件。</p>\n<blockquote>\n<p>没有developer_identity.p12证书</p>\n<p>请新建一个Flex手机工程，在工程上点击右键，选择属性，并选择 Flex构建打包 -&gt; Apple iOS，在右边选择 数字签名 -&gt; 创建，即可创建一个可用的数字签名证书。</p>\n</blockquote>"},{"title":"黑魔法之Xcode Plugin开发","date":"2014-11-24T14:42:01.000Z","_content":"\nXcode 插件的黑科技\n\n##1. 取得项目路径\n\n先贴段代码：\n\n    NSString *workspacePath = @\"\";\n    \n    // to find current project path\n    NSArray *workspaceWindowControllers = [NSClassFromString(@\"IDEWorkspaceWindowController\") valueForKey:@\"workspaceWindowControllers\"];\n    id workSpace;\n    for (id controller in workspaceWindowControllers) {\n        if ([[controller valueForKey:@\"window\"] isEqual:[NSApp keyWindow]]) {\n            workSpace = [controller valueForKey:@\"_workspace\"];\n        }\n    }\n    \n    if (workSpace) {\n        workspacePath = [[workSpace valueForKey:@\"representingFilePath\"] valueForKey:@\"_pathString\"];\n    }\n    \n这段代码位于 BMPlugin.m 中，作用是取得当前 workspace，并读取其文件路径。\n\n <!-- more --> \n\n> 由于 Xcode 插件开发基本无文档可查，这段代码也是从网上 copy 回来的。完全没有系统了解的方法。\n> \n> 值得注意的是，这些都不是公开的API，所以，Xcode 版本迭代时，注意检查兼容性。\n> \n\n##2. 标示支持的 Xcode 版本\n\n插件项目的 info.plist 需要添加 DVTPlugInCompatibilityUUIDs 标示支持的 Xcode 版本。\n\n当前 Xcode 版本的 DVTPlugInCompatibilityUUID 可在 Xcode.app/Contents/Info.plist 找到。\n\n如果对应 Xcode 版本的 DVTPlugInCompatibilityUUID 没有被添加到 info.plist 中，那么该版本 Xcode 启动时不会加载插件。\n\n##3. XCPluginHasUI NO\n\n> Set XCPluginHasUI in Info.plist to YES to disable your plugin\n\n记得这个属性 XCPluginHasUI 需要设置为 NO。\n\n##4. 其他需要注意的\n\n编译的时候记得把 .xib 界面文件添加到 Compile Sources 里面，否则，编译出来的包里面没有对应的 .nib 。\n","source":"_posts/Black_Magic_Xcode_Plugin.md","raw":"title: 黑魔法之Xcode Plugin开发 \ndate: 2014-11-24 22:42:01\ntags: [Xcode,Plugin]\n---\n\nXcode 插件的黑科技\n\n##1. 取得项目路径\n\n先贴段代码：\n\n    NSString *workspacePath = @\"\";\n    \n    // to find current project path\n    NSArray *workspaceWindowControllers = [NSClassFromString(@\"IDEWorkspaceWindowController\") valueForKey:@\"workspaceWindowControllers\"];\n    id workSpace;\n    for (id controller in workspaceWindowControllers) {\n        if ([[controller valueForKey:@\"window\"] isEqual:[NSApp keyWindow]]) {\n            workSpace = [controller valueForKey:@\"_workspace\"];\n        }\n    }\n    \n    if (workSpace) {\n        workspacePath = [[workSpace valueForKey:@\"representingFilePath\"] valueForKey:@\"_pathString\"];\n    }\n    \n这段代码位于 BMPlugin.m 中，作用是取得当前 workspace，并读取其文件路径。\n\n <!-- more --> \n\n> 由于 Xcode 插件开发基本无文档可查，这段代码也是从网上 copy 回来的。完全没有系统了解的方法。\n> \n> 值得注意的是，这些都不是公开的API，所以，Xcode 版本迭代时，注意检查兼容性。\n> \n\n##2. 标示支持的 Xcode 版本\n\n插件项目的 info.plist 需要添加 DVTPlugInCompatibilityUUIDs 标示支持的 Xcode 版本。\n\n当前 Xcode 版本的 DVTPlugInCompatibilityUUID 可在 Xcode.app/Contents/Info.plist 找到。\n\n如果对应 Xcode 版本的 DVTPlugInCompatibilityUUID 没有被添加到 info.plist 中，那么该版本 Xcode 启动时不会加载插件。\n\n##3. XCPluginHasUI NO\n\n> Set XCPluginHasUI in Info.plist to YES to disable your plugin\n\n记得这个属性 XCPluginHasUI 需要设置为 NO。\n\n##4. 其他需要注意的\n\n编译的时候记得把 .xib 界面文件添加到 Compile Sources 里面，否则，编译出来的包里面没有对应的 .nib 。\n","slug":"Black_Magic_Xcode_Plugin","published":1,"updated":"2016-08-08T11:42:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civzfqil6000bf66oyoa4z9hq","content":"<p>Xcode 插件的黑科技</p>\n<p>##1. 取得项目路径</p>\n<p>先贴段代码：</p>\n<pre><code>NSString *workspacePath = @&quot;&quot;;\n\n// to find current project path\nNSArray *workspaceWindowControllers = [NSClassFromString(@&quot;IDEWorkspaceWindowController&quot;) valueForKey:@&quot;workspaceWindowControllers&quot;];\nid workSpace;\nfor (id controller in workspaceWindowControllers) {\n    if ([[controller valueForKey:@&quot;window&quot;] isEqual:[NSApp keyWindow]]) {\n        workSpace = [controller valueForKey:@&quot;_workspace&quot;];\n    }\n}\n\nif (workSpace) {\n    workspacePath = [[workSpace valueForKey:@&quot;representingFilePath&quot;] valueForKey:@&quot;_pathString&quot;];\n}\n</code></pre><p>这段代码位于 BMPlugin.m 中，作用是取得当前 workspace，并读取其文件路径。</p>\n <a id=\"more\"></a> \n<blockquote>\n<p>由于 Xcode 插件开发基本无文档可查，这段代码也是从网上 copy 回来的。完全没有系统了解的方法。</p>\n<p>值得注意的是，这些都不是公开的API，所以，Xcode 版本迭代时，注意检查兼容性。</p>\n</blockquote>\n<p>##2. 标示支持的 Xcode 版本</p>\n<p>插件项目的 info.plist 需要添加 DVTPlugInCompatibilityUUIDs 标示支持的 Xcode 版本。</p>\n<p>当前 Xcode 版本的 DVTPlugInCompatibilityUUID 可在 Xcode.app/Contents/Info.plist 找到。</p>\n<p>如果对应 Xcode 版本的 DVTPlugInCompatibilityUUID 没有被添加到 info.plist 中，那么该版本 Xcode 启动时不会加载插件。</p>\n<p>##3. XCPluginHasUI NO</p>\n<blockquote>\n<p>Set XCPluginHasUI in Info.plist to YES to disable your plugin</p>\n</blockquote>\n<p>记得这个属性 XCPluginHasUI 需要设置为 NO。</p>\n<p>##4. 其他需要注意的</p>\n<p>编译的时候记得把 .xib 界面文件添加到 Compile Sources 里面，否则，编译出来的包里面没有对应的 .nib 。</p>\n","excerpt":"<p>Xcode 插件的黑科技</p>\n<p>##1. 取得项目路径</p>\n<p>先贴段代码：</p>\n<pre><code>NSString *workspacePath = @&quot;&quot;;\n\n// to find current project path\nNSArray *workspaceWindowControllers = [NSClassFromString(@&quot;IDEWorkspaceWindowController&quot;) valueForKey:@&quot;workspaceWindowControllers&quot;];\nid workSpace;\nfor (id controller in workspaceWindowControllers) {\n    if ([[controller valueForKey:@&quot;window&quot;] isEqual:[NSApp keyWindow]]) {\n        workSpace = [controller valueForKey:@&quot;_workspace&quot;];\n    }\n}\n\nif (workSpace) {\n    workspacePath = [[workSpace valueForKey:@&quot;representingFilePath&quot;] valueForKey:@&quot;_pathString&quot;];\n}\n</code></pre><p>这段代码位于 BMPlugin.m 中，作用是取得当前 workspace，并读取其文件路径。</p>","more":"<blockquote>\n<p>由于 Xcode 插件开发基本无文档可查，这段代码也是从网上 copy 回来的。完全没有系统了解的方法。</p>\n<p>值得注意的是，这些都不是公开的API，所以，Xcode 版本迭代时，注意检查兼容性。</p>\n</blockquote>\n<p>##2. 标示支持的 Xcode 版本</p>\n<p>插件项目的 info.plist 需要添加 DVTPlugInCompatibilityUUIDs 标示支持的 Xcode 版本。</p>\n<p>当前 Xcode 版本的 DVTPlugInCompatibilityUUID 可在 Xcode.app/Contents/Info.plist 找到。</p>\n<p>如果对应 Xcode 版本的 DVTPlugInCompatibilityUUID 没有被添加到 info.plist 中，那么该版本 Xcode 启动时不会加载插件。</p>\n<p>##3. XCPluginHasUI NO</p>\n<blockquote>\n<p>Set XCPluginHasUI in Info.plist to YES to disable your plugin</p>\n</blockquote>\n<p>记得这个属性 XCPluginHasUI 需要设置为 NO。</p>\n<p>##4. 其他需要注意的</p>\n<p>编译的时候记得把 .xib 界面文件添加到 Compile Sources 里面，否则，编译出来的包里面没有对应的 .nib 。</p>"},{"title":"推荐一个系列视频《Extra Credits》","date":"2014-11-26T16:43:39.000Z","_content":"\n最近中午的午休时间都在看[《Extra Credits》](http://extra-credits.net/)，挺赞的，是一个讨论游戏行业相关话题的系列视频。在此推荐一下。\n\n![Extra Credits](/images/extra_credits.png)\n\n <!-- more -->\n\n这是wikipedia上的介绍。\n\n>Extra Credits is a video lesson series presented by game designer James Portnow, animator/narrator Daniel Floyd, and artists Allison Theus, Elisa \"LeeLee\" Scaldaferri, Scott DeWitt, and Dan Jones. The series of videos discuss issues pertinent to video games and game studies, particularly discussing issues concerning video game development, addressing the legitimacy of video games as art, and creating intellectual discourse on important issues in gaming culture.[1]\n>\n> -- WIKIPEDIA\n\nLinks:\n\n[Official Website](http://extra-credits.net/)\n\n[Extra Credits's channel on YouTube](https://www.youtube.com/user/ExtraCreditz)\n\n[the wikipedia link fo Extra Credits](http://en.wikipedia.org/wiki/Extra_Credits)\n","source":"_posts/Extra_Credits.md","raw":"title: 推荐一个系列视频《Extra Credits》\ndate: 2014-11-27 00:43:39\ntags: [Extra Credits,Game,Video Lesson Series]\n---\n\n最近中午的午休时间都在看[《Extra Credits》](http://extra-credits.net/)，挺赞的，是一个讨论游戏行业相关话题的系列视频。在此推荐一下。\n\n![Extra Credits](/images/extra_credits.png)\n\n <!-- more -->\n\n这是wikipedia上的介绍。\n\n>Extra Credits is a video lesson series presented by game designer James Portnow, animator/narrator Daniel Floyd, and artists Allison Theus, Elisa \"LeeLee\" Scaldaferri, Scott DeWitt, and Dan Jones. The series of videos discuss issues pertinent to video games and game studies, particularly discussing issues concerning video game development, addressing the legitimacy of video games as art, and creating intellectual discourse on important issues in gaming culture.[1]\n>\n> -- WIKIPEDIA\n\nLinks:\n\n[Official Website](http://extra-credits.net/)\n\n[Extra Credits's channel on YouTube](https://www.youtube.com/user/ExtraCreditz)\n\n[the wikipedia link fo Extra Credits](http://en.wikipedia.org/wiki/Extra_Credits)\n","slug":"Extra_Credits","published":1,"updated":"2016-11-26T16:47:56.000Z","_id":"civzfqil9000ff66opt2q7zgg","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近中午的午休时间都在看<a href=\"http://extra-credits.net/\" target=\"_blank\" rel=\"external\">《Extra Credits》</a>，挺赞的，是一个讨论游戏行业相关话题的系列视频。在此推荐一下。</p>\n<p><img src=\"/images/extra_credits.png\" alt=\"Extra Credits\"></p>\n <a id=\"more\"></a>\n<p>这是wikipedia上的介绍。</p>\n<blockquote>\n<p>Extra Credits is a video lesson series presented by game designer James Portnow, animator/narrator Daniel Floyd, and artists Allison Theus, Elisa “LeeLee” Scaldaferri, Scott DeWitt, and Dan Jones. The series of videos discuss issues pertinent to video games and game studies, particularly discussing issues concerning video game development, addressing the legitimacy of video games as art, and creating intellectual discourse on important issues in gaming culture.[1]</p>\n<p>– WIKIPEDIA</p>\n</blockquote>\n<p>Links:</p>\n<p><a href=\"http://extra-credits.net/\" target=\"_blank\" rel=\"external\">Official Website</a></p>\n<p><a href=\"https://www.youtube.com/user/ExtraCreditz\" target=\"_blank\" rel=\"external\">Extra Credits’s channel on YouTube</a></p>\n<p><a href=\"http://en.wikipedia.org/wiki/Extra_Credits\" target=\"_blank\" rel=\"external\">the wikipedia link fo Extra Credits</a></p>\n","excerpt":"<p>最近中午的午休时间都在看<a href=\"http://extra-credits.net/\">《Extra Credits》</a>，挺赞的，是一个讨论游戏行业相关话题的系列视频。在此推荐一下。</p>\n<p><img src=\"/images/extra_credits.png\" alt=\"Extra Credits\"></p>","more":"<p>这是wikipedia上的介绍。</p>\n<blockquote>\n<p>Extra Credits is a video lesson series presented by game designer James Portnow, animator/narrator Daniel Floyd, and artists Allison Theus, Elisa “LeeLee” Scaldaferri, Scott DeWitt, and Dan Jones. The series of videos discuss issues pertinent to video games and game studies, particularly discussing issues concerning video game development, addressing the legitimacy of video games as art, and creating intellectual discourse on important issues in gaming culture.[1]</p>\n<p>– WIKIPEDIA</p>\n</blockquote>\n<p>Links:</p>\n<p><a href=\"http://extra-credits.net/\">Official Website</a></p>\n<p><a href=\"https://www.youtube.com/user/ExtraCreditz\">Extra Credits’s channel on YouTube</a></p>\n<p><a href=\"http://en.wikipedia.org/wiki/Extra_Credits\">the wikipedia link fo Extra Credits</a></p>"},{"title":"入职作业之json数据与lua vlaue转换","date":"2015-01-09T13:56:39.000Z","_content":"\n\n题目任务描述：封装json格式的数据与lua value间的互相转换功能\n\n下载ECMA-404的描述文件，观察json的数据格式。\n\n根据描述，一个json value可以是这些类型: object, array, number, string, true, false, or null。\n\n![value](/images/value.png)\n\n <!-- more -->\n\n下面是描述几种数据类型的图。\n\n![object](/images/object.png)\n\n![array](/images/array.png)\n\n![number](/images/number.png)\n\n![string](/images/string.png)\n\n这些图的描述能力应该等同BNF，所以需要处理的操作大概有：\n\n1. 串联\t\t\t\t\t如，C等于A串联B(C＝AB)，即匹配一个C等同于匹配一个A接着匹配一个B\n2. 并联\t\t\t\t\t如，C等于A并联A(C=A|B)，即匹配一个C等同于匹配一个A或者匹配一个B\n3. 匹配0或1次\t\t\t如，C等于匹配A0或1次(C=A?)，即匹配一个C等同于匹配一个A0或多次，该操作可以由 C=A|\"\" 代替，其中\"\"表示空串。\n4. 匹配0或任意次\t\t如，C等于匹配A0或任意次(C=A*)，即匹配一个C等同于匹配一个A0或任意次\n\n则最简单的，上述的value可以描述成\n\n\tvalue ＝ object | array | number | string | true | false | null\n\nobject可以描述成，(引号内表示终结符，括号指示结合顺序)\n\n\tobject ＝ \"{\" ((string \":\" value) (\",\" string \":\" value)*)? \"}\"\n\n其他就依次类推...\n\n---\n\n回来开始写代码：\n\n先定义最简单的匹配函数的格式：\n\n\t -- the matcher function\n\t function matcher(json_str, start)\n\t \t...\n\t \treturn result, value, new_start\n\t end\n\n最简单的匹配函数，接受一个待匹配的字符串和一个起始下标，返回匹配结果（true|false），匹配成功后的返回数据，一个新的起始下标。\n\n定义两个最简单的结果处理函数，一个不处理输入直接返回，另一个直接返回nil，后面会常用到\n\n\t-- result handler\n\tlocal no_h = function(v) return v end\n\tlocal nil_h = function() return nil end\n\n定义一个生成基本匹配函数的生成函数，接受一个lua find的匹配表达式和一个结果处理函数，返回一个匹配函数。\n\n\t-- matcher function generator\n\tlocal generator = function(pattern, handler)\n\n\t  -- the matcher function\n\t  function matcher(json_str, start)\n\t    local _, e = string.find(json_str, \"^\"..pattern, start)\n\n\t    if e then\n\t      return true, handler(string.sub(json_str, start, e)), e+1\n\t    else\n\t      return false, nil, start\n\t    end\n\n\t  end\n\n\t  return matcher\n\tend\n\n根据最开始的描述，需要的操作至少还有：并联、串联、匹配0或一次、匹配0或任意次。\n\n下面是并联多个匹配函数的并联操作，输入一个匹配函数列表和一个结果处理函数，返回一个并联后的匹配函数。\n\n\t-- parallelize matchers\n\tparallelize = function(matchers,handler)\n\t  if handler == nil then\n\t    handler = no_h\n\t  end\n\n\t  -- the paralleized matcher function\n\t  function p_matcher(json_str, start)\n\t    local r,v,s\n\n\t    for i=1,#matchers do\n\t      r,v,s = matchers[i](json_str, start)\n\t      if r then\n\t        if handler == nil_h then return true, nil, s end\n\t        if handler == no_h then return true, v, s end\n\t        return r,handler(v),s\n\t      end\n\t    end\n\n\t    return false,nil,start\n\t  end\n\n\t  return p_matcher\n\tend\n\n下面是串联多个匹配函数的串联操作，输入一个匹配函数列表和一个结果处理函数，返回一个串联后的匹配函数。\n\n\t-- serialize matchers\n\tserialize = function(matchers,handler)\n\t  if handler == nil then\n\t    handler = no_h\n\t  end\n\n\t  -- the serialized matcher function\n\t  function s_matcher(json_str, start)\n\t    local r,v,s = false,nil,start\n\t    local results = {}\n\n\t    for i=1,#matchers do\n\t      r,v,s = matchers[i](json_str, s)\n\t      if r == false then\n\t        return false,nil,start\n\t      end\n\t      table.insert(results,v)\n\t    end\n\n\t    if handler == nil_h then return true, nil, s end\n\t    if handler == no_h then return true, results, s end\n\t    return true,handler(results),s\n\t  end\n\n\t  return s_matcher\n\tend\n\n匹配0或任意次和匹配1或任意次之间存在转换关系，实现中选了1或任意次匹配作为原子操作，0或任意次可以描述为:(\"\"表示空串)\n\n\t0_or_more = one_or_more | \"\"\n\n下面是1或任意次匹配操作，接受一个匹配函数和一个结果处理函数，返回一个匹配1次或任意次的匹配函数。\n\n\t-- make a matcher match one or more\n\tone_or_more = function(matcher, handler)\n\t  if handler == nil then\n\t    handler = function(v) return v end\n\t  end\n\n\t  -- the one or more matcher function\n\t  function oom_matcher(json_str, start)\n\t    local r,v,s = false,nil,start\n\t    local results = {}\n\n\t    r,v,s = matcher(json_str, s)\n\t    if r == false then\n\t      return false,nil,s\n\t    end\n\t    table.insert(results,v)\n\n\t    while true do\n\t      r,v,s = matcher(json_str, s)\n\t      if r == false then\n\t        break\n\t      end\n\t      table.insert(results,v)\n\t    end\n\n\t    if handler == nil_h then return true, nil, s end\n\t    if handler == no_h then return true, results, s end\n\t    return true,handler(results),s\n\t  end\n\n\t  return oom_matcher\n\tend\n\n下面定义了一个空串匹配函数，和定义一个0或1次匹配操作函数。\n\n\t-- empty\n\tlocal empty_m = generator(\"\",nil_h)\n\n\t-- or empty helper\n\tlocal or_empty = function(matcher)\n\t  return parallelize{matcher,empty_m}\n\tend\n\n定义完这些，就可以开始描述我们的匹配函数了。\n\n\t-- main matchers\n\tlocal null_m, boolean_m, number_m, string_m, object_m, array_m, value_m, value_a\n\nvalue匹配函数的描述，value为number_m,string_m,boolean_m,null_m,object_m,array_m并联。\n\n\t-- value\n\tvalue_m = function(json_str,s)\n\t  -- use value_a to bootup\n\t  if value_a==nil then\n\t    value_a = parallelize{number_m,string_m,boolean_m,null_m,object_m,array_m}\n\t  end\n\t  return value_a(json_str,s)\n\tend\n\n这里的value需要使用value_a来协助描述，因为代码最终会出现循环引用，此时number_m,string_m,boolean_m,null_m,object_m,array_m都还没定义，需要在定义好后，才能生成value的匹配函数。\n\n匹配null的函数，使用生成函数生成。\n\n\t-- null\n\tnull_m = generator(\"null\",function() return nil end)\n\n匹配boolean的函数，true和false使用生成函数生成，然后并联true和false匹配函数，生成boolean匹配函数。\n\n\t-- boolean\n\tlocal true_m = generator(\"true\", function() return true end)\n\tlocal false_m = generator(\"false\", function() return false end)\n\tboolean_m = parallelize{true_m,false_m}\n\n匹配number的函数，根据最上面的图，描述为如下：\n\n\t-- number\n\tlocal sign_m = generator(\"[+-]?\",no_h)\n\tlocal minus_or_no_m = generator(\"[-]?\",no_h)\n\tlocal number_no_0_m = generator(\"[1-9]%d*\",no_h)\n\tlocal number_0_m = generator(\"0\",no_h)\n\tlocal dot_number_m = generator(\"%.%d+\",no_h)\n\tlocal e_number_m = generator(\"[eE][+-]?%d+\",no_h)\n\n\tnumber_m = serialize(\n\t  {\n\t    minus_or_no_m,\n\t    parallelize{number_0_m,number_no_0_m},\n\t    or_empty(dot_number_m),\n\t    or_empty(e_number_m)\n\t  },\n\t  function(t) return tonumber(table.concat(t)) end\n\t  )\n\nstring需要处理unicode2utf8编码转换及转义符号。\n\nunicode到utf8转换函数：\n\n\t-- string\n\tlocal function hex2utf8(hex)\n\t  local v, utf8str = 0, \"\"  \n\t  v = tonumber(hex,16)\n\t  if v >= 0x0800 then\n\t    utf8str = string.char(v%0x40+0x80)\n\t    v = math.modf(v/0x40)\n\t    vv = v % 0x40\n\t    utf8str = string.char(vv+0x80) .. utf8str\n\t    v = math.modf(v/0x40)\n\t    utf8str = string.char(v+0xe0) .. utf8str\n\t  elseif v >= 0x0080 then\n\t    utf8str = string.char(v%0x40+0x80)\n\t    v = math.modf(v/0x40)\n\t    utf8str = string.char(v+0xc0) .. utf8str\n\t  else\n\t    utf8str = string.char(v)\n\t  end\n\t  return utf8str\n\tend\n\n匹配引号的函数，使用生成函数生成。\n\n\t-- string\n\tlocal quotation_m = generator(\"\\\"\",nil_h)\n\n匹配非\"\\\"字符的函数，生成函数生成。\n\n\tlocal char_m = generator(\"[^\\\"\\\\]+\", no_h)\n\n转义表\n\n\tlocal escape_char = {\n\t    [\"\\\"\"] = \"\\\"\",\n\t    [\"\\\\\"] = \"\\\\\",\n\t    [\"/\"]  = \"/\",\n\t    [\"b\"]  = \"\\b\",\n\t    [\"f\"]  = \"\\f\",\n\t    [\"n\"]  = \"\\n\",\n\t    [\"r\"]  = \"\\r\",\n\t    [\"t\"]  = \"\\t\",\n\t  }\n\n匹配\"\\\"字符函数。\n\n\tlocal backslash_m = generator(\"\\\\\", nil_h)\n\n转义符号匹配和处理函数，注意传入的结果处理函数。\n\n\tlocal escape_char_m = generator(\"[\\\"\\\\/bfnrt]\",function(c) return escape_char[c] end)\n\nunicode匹配和处理函数，注意传入的结果处理函数。\n\n\tlocal unicode_char_m = generator(\"u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]\", function(v) return hex2utf8(string.sub(v,2)) end)\n\nstring的描述\n\n\tstring_m = serialize(\n\t  {\n\t    quotation_m,\n\t    or_empty(\n\t        one_or_more(\n\t          parallelize{\n\t            char_m,\n\t            serialize(\n\t              {\n\t                backslash_m,\n\t                parallelize{escape_char_m,unicode_char_m}\n\t              },\n\t              table.concat\n\t              ),\n\t            },\n\t          table.concat\n\t          )\n\t      ),\n\t    quotation_m\n\t  },\n\t  table.concat\n\t)\n\nobject的描述，各层结果处理函数比较复杂。\n\n\t-- object\n\t-- brace_l\n\tlocal brace_l_m = generator(\"%s*{%s*\",nil_h)\n\tlocal brace_r_m = generator(\"%s*}%s*\",nil_h)\n\tlocal colon_m = generator(\"%s*:%s*\",nil_h)\n\tlocal comma_m = generator(\"%s*,%s*\",nil_h)\n\n\tlocal object_item_m = serialize{string_m,colon_m,value_m}\n\n\tobject_m = serialize(\n\t  {\n\t    brace_l_m,\n\t    or_empty(\n\t      serialize(\n\t        {\n\t          object_item_m,\n\t          or_empty(\n\t            one_or_more(\n\t              serialize(\n\t                {comma_m,object_item_m},\n\t                function(t) return t[1] end\n\t              )\n\t            )\n\t          )\n\t        },\n\t        function(t)\n\t          if t[2] then\n\t            table.insert(t[2],t[1])\n\t            return t[2]\n\t          else\n\t            return {t[1]}\n\t          end\n\t        end\n\t      )\n\t    ),\n\t    brace_r_m\n\t  },\n\t  function(t)\n\t    local o = {}\n\n\t    if t[1] then\n\t      for k,v in pairs(t[1]) do\n\t        o[v[1]] = v[2]\n\t      end\n\t    end\n\n\t    return o\n\t  end\n\t)\n\narray的描述，array需要保持一个状态index，如果直接用基本操作描述，传入的结果处理函数会比较蛋疼，所以用函数实现了。\n\n\t-- arrary\n\tlocal bracket_l_m = generator(\"%s*%[%s*\",nil_h)\n\tlocal bracket_r_m = generator(\"%s*%]%s*\",nil_h)\n\n\tarray_m = function(json_str, start)\n\n\t  local array,index = {}, 1\n\t  local add_item = function(v) array[index] = v[1]; index=index+1 end\n\t  local array_item_m = serialize({value_m},add_item)\n\n\t  local array_a = serialize{\n\t      bracket_l_m,\n\t      or_empty(\n\t        serialize{\n\t            array_item_m,\n\t            or_empty(\n\t              one_or_more(serialize{comma_m,array_item_m})\n\t                )\n\t              }\n\t          ),\n\t      bracket_r_m\n\t    }\n\n\t  local r,v,s = array_a(json_str,start)\n\t  return r,array,s\n\tend\n\n最后，匹配函数\n\n\tlocal function Marshal(json_str)\n\t  local result,value,start = value_m(json_str,1)\n\t  if result --and start == #json_str+1\n\t  then\n\t    return value\n\t  else\n\t    return nil, \"error_type\"\n\t  end\n\tend\n\nlua table 反解析成 json string 的比较直观，对每一种lua value类型写一个转换函数即可，此处不冗述。\n","source":"_posts/Homework_Lua.md","raw":"title: 入职作业之json数据与lua vlaue转换\ndate: 2015-01-09 21:56:39\ntags: [lua,json,Parser]\n---\n\n\n题目任务描述：封装json格式的数据与lua value间的互相转换功能\n\n下载ECMA-404的描述文件，观察json的数据格式。\n\n根据描述，一个json value可以是这些类型: object, array, number, string, true, false, or null。\n\n![value](/images/value.png)\n\n <!-- more -->\n\n下面是描述几种数据类型的图。\n\n![object](/images/object.png)\n\n![array](/images/array.png)\n\n![number](/images/number.png)\n\n![string](/images/string.png)\n\n这些图的描述能力应该等同BNF，所以需要处理的操作大概有：\n\n1. 串联\t\t\t\t\t如，C等于A串联B(C＝AB)，即匹配一个C等同于匹配一个A接着匹配一个B\n2. 并联\t\t\t\t\t如，C等于A并联A(C=A|B)，即匹配一个C等同于匹配一个A或者匹配一个B\n3. 匹配0或1次\t\t\t如，C等于匹配A0或1次(C=A?)，即匹配一个C等同于匹配一个A0或多次，该操作可以由 C=A|\"\" 代替，其中\"\"表示空串。\n4. 匹配0或任意次\t\t如，C等于匹配A0或任意次(C=A*)，即匹配一个C等同于匹配一个A0或任意次\n\n则最简单的，上述的value可以描述成\n\n\tvalue ＝ object | array | number | string | true | false | null\n\nobject可以描述成，(引号内表示终结符，括号指示结合顺序)\n\n\tobject ＝ \"{\" ((string \":\" value) (\",\" string \":\" value)*)? \"}\"\n\n其他就依次类推...\n\n---\n\n回来开始写代码：\n\n先定义最简单的匹配函数的格式：\n\n\t -- the matcher function\n\t function matcher(json_str, start)\n\t \t...\n\t \treturn result, value, new_start\n\t end\n\n最简单的匹配函数，接受一个待匹配的字符串和一个起始下标，返回匹配结果（true|false），匹配成功后的返回数据，一个新的起始下标。\n\n定义两个最简单的结果处理函数，一个不处理输入直接返回，另一个直接返回nil，后面会常用到\n\n\t-- result handler\n\tlocal no_h = function(v) return v end\n\tlocal nil_h = function() return nil end\n\n定义一个生成基本匹配函数的生成函数，接受一个lua find的匹配表达式和一个结果处理函数，返回一个匹配函数。\n\n\t-- matcher function generator\n\tlocal generator = function(pattern, handler)\n\n\t  -- the matcher function\n\t  function matcher(json_str, start)\n\t    local _, e = string.find(json_str, \"^\"..pattern, start)\n\n\t    if e then\n\t      return true, handler(string.sub(json_str, start, e)), e+1\n\t    else\n\t      return false, nil, start\n\t    end\n\n\t  end\n\n\t  return matcher\n\tend\n\n根据最开始的描述，需要的操作至少还有：并联、串联、匹配0或一次、匹配0或任意次。\n\n下面是并联多个匹配函数的并联操作，输入一个匹配函数列表和一个结果处理函数，返回一个并联后的匹配函数。\n\n\t-- parallelize matchers\n\tparallelize = function(matchers,handler)\n\t  if handler == nil then\n\t    handler = no_h\n\t  end\n\n\t  -- the paralleized matcher function\n\t  function p_matcher(json_str, start)\n\t    local r,v,s\n\n\t    for i=1,#matchers do\n\t      r,v,s = matchers[i](json_str, start)\n\t      if r then\n\t        if handler == nil_h then return true, nil, s end\n\t        if handler == no_h then return true, v, s end\n\t        return r,handler(v),s\n\t      end\n\t    end\n\n\t    return false,nil,start\n\t  end\n\n\t  return p_matcher\n\tend\n\n下面是串联多个匹配函数的串联操作，输入一个匹配函数列表和一个结果处理函数，返回一个串联后的匹配函数。\n\n\t-- serialize matchers\n\tserialize = function(matchers,handler)\n\t  if handler == nil then\n\t    handler = no_h\n\t  end\n\n\t  -- the serialized matcher function\n\t  function s_matcher(json_str, start)\n\t    local r,v,s = false,nil,start\n\t    local results = {}\n\n\t    for i=1,#matchers do\n\t      r,v,s = matchers[i](json_str, s)\n\t      if r == false then\n\t        return false,nil,start\n\t      end\n\t      table.insert(results,v)\n\t    end\n\n\t    if handler == nil_h then return true, nil, s end\n\t    if handler == no_h then return true, results, s end\n\t    return true,handler(results),s\n\t  end\n\n\t  return s_matcher\n\tend\n\n匹配0或任意次和匹配1或任意次之间存在转换关系，实现中选了1或任意次匹配作为原子操作，0或任意次可以描述为:(\"\"表示空串)\n\n\t0_or_more = one_or_more | \"\"\n\n下面是1或任意次匹配操作，接受一个匹配函数和一个结果处理函数，返回一个匹配1次或任意次的匹配函数。\n\n\t-- make a matcher match one or more\n\tone_or_more = function(matcher, handler)\n\t  if handler == nil then\n\t    handler = function(v) return v end\n\t  end\n\n\t  -- the one or more matcher function\n\t  function oom_matcher(json_str, start)\n\t    local r,v,s = false,nil,start\n\t    local results = {}\n\n\t    r,v,s = matcher(json_str, s)\n\t    if r == false then\n\t      return false,nil,s\n\t    end\n\t    table.insert(results,v)\n\n\t    while true do\n\t      r,v,s = matcher(json_str, s)\n\t      if r == false then\n\t        break\n\t      end\n\t      table.insert(results,v)\n\t    end\n\n\t    if handler == nil_h then return true, nil, s end\n\t    if handler == no_h then return true, results, s end\n\t    return true,handler(results),s\n\t  end\n\n\t  return oom_matcher\n\tend\n\n下面定义了一个空串匹配函数，和定义一个0或1次匹配操作函数。\n\n\t-- empty\n\tlocal empty_m = generator(\"\",nil_h)\n\n\t-- or empty helper\n\tlocal or_empty = function(matcher)\n\t  return parallelize{matcher,empty_m}\n\tend\n\n定义完这些，就可以开始描述我们的匹配函数了。\n\n\t-- main matchers\n\tlocal null_m, boolean_m, number_m, string_m, object_m, array_m, value_m, value_a\n\nvalue匹配函数的描述，value为number_m,string_m,boolean_m,null_m,object_m,array_m并联。\n\n\t-- value\n\tvalue_m = function(json_str,s)\n\t  -- use value_a to bootup\n\t  if value_a==nil then\n\t    value_a = parallelize{number_m,string_m,boolean_m,null_m,object_m,array_m}\n\t  end\n\t  return value_a(json_str,s)\n\tend\n\n这里的value需要使用value_a来协助描述，因为代码最终会出现循环引用，此时number_m,string_m,boolean_m,null_m,object_m,array_m都还没定义，需要在定义好后，才能生成value的匹配函数。\n\n匹配null的函数，使用生成函数生成。\n\n\t-- null\n\tnull_m = generator(\"null\",function() return nil end)\n\n匹配boolean的函数，true和false使用生成函数生成，然后并联true和false匹配函数，生成boolean匹配函数。\n\n\t-- boolean\n\tlocal true_m = generator(\"true\", function() return true end)\n\tlocal false_m = generator(\"false\", function() return false end)\n\tboolean_m = parallelize{true_m,false_m}\n\n匹配number的函数，根据最上面的图，描述为如下：\n\n\t-- number\n\tlocal sign_m = generator(\"[+-]?\",no_h)\n\tlocal minus_or_no_m = generator(\"[-]?\",no_h)\n\tlocal number_no_0_m = generator(\"[1-9]%d*\",no_h)\n\tlocal number_0_m = generator(\"0\",no_h)\n\tlocal dot_number_m = generator(\"%.%d+\",no_h)\n\tlocal e_number_m = generator(\"[eE][+-]?%d+\",no_h)\n\n\tnumber_m = serialize(\n\t  {\n\t    minus_or_no_m,\n\t    parallelize{number_0_m,number_no_0_m},\n\t    or_empty(dot_number_m),\n\t    or_empty(e_number_m)\n\t  },\n\t  function(t) return tonumber(table.concat(t)) end\n\t  )\n\nstring需要处理unicode2utf8编码转换及转义符号。\n\nunicode到utf8转换函数：\n\n\t-- string\n\tlocal function hex2utf8(hex)\n\t  local v, utf8str = 0, \"\"  \n\t  v = tonumber(hex,16)\n\t  if v >= 0x0800 then\n\t    utf8str = string.char(v%0x40+0x80)\n\t    v = math.modf(v/0x40)\n\t    vv = v % 0x40\n\t    utf8str = string.char(vv+0x80) .. utf8str\n\t    v = math.modf(v/0x40)\n\t    utf8str = string.char(v+0xe0) .. utf8str\n\t  elseif v >= 0x0080 then\n\t    utf8str = string.char(v%0x40+0x80)\n\t    v = math.modf(v/0x40)\n\t    utf8str = string.char(v+0xc0) .. utf8str\n\t  else\n\t    utf8str = string.char(v)\n\t  end\n\t  return utf8str\n\tend\n\n匹配引号的函数，使用生成函数生成。\n\n\t-- string\n\tlocal quotation_m = generator(\"\\\"\",nil_h)\n\n匹配非\"\\\"字符的函数，生成函数生成。\n\n\tlocal char_m = generator(\"[^\\\"\\\\]+\", no_h)\n\n转义表\n\n\tlocal escape_char = {\n\t    [\"\\\"\"] = \"\\\"\",\n\t    [\"\\\\\"] = \"\\\\\",\n\t    [\"/\"]  = \"/\",\n\t    [\"b\"]  = \"\\b\",\n\t    [\"f\"]  = \"\\f\",\n\t    [\"n\"]  = \"\\n\",\n\t    [\"r\"]  = \"\\r\",\n\t    [\"t\"]  = \"\\t\",\n\t  }\n\n匹配\"\\\"字符函数。\n\n\tlocal backslash_m = generator(\"\\\\\", nil_h)\n\n转义符号匹配和处理函数，注意传入的结果处理函数。\n\n\tlocal escape_char_m = generator(\"[\\\"\\\\/bfnrt]\",function(c) return escape_char[c] end)\n\nunicode匹配和处理函数，注意传入的结果处理函数。\n\n\tlocal unicode_char_m = generator(\"u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]\", function(v) return hex2utf8(string.sub(v,2)) end)\n\nstring的描述\n\n\tstring_m = serialize(\n\t  {\n\t    quotation_m,\n\t    or_empty(\n\t        one_or_more(\n\t          parallelize{\n\t            char_m,\n\t            serialize(\n\t              {\n\t                backslash_m,\n\t                parallelize{escape_char_m,unicode_char_m}\n\t              },\n\t              table.concat\n\t              ),\n\t            },\n\t          table.concat\n\t          )\n\t      ),\n\t    quotation_m\n\t  },\n\t  table.concat\n\t)\n\nobject的描述，各层结果处理函数比较复杂。\n\n\t-- object\n\t-- brace_l\n\tlocal brace_l_m = generator(\"%s*{%s*\",nil_h)\n\tlocal brace_r_m = generator(\"%s*}%s*\",nil_h)\n\tlocal colon_m = generator(\"%s*:%s*\",nil_h)\n\tlocal comma_m = generator(\"%s*,%s*\",nil_h)\n\n\tlocal object_item_m = serialize{string_m,colon_m,value_m}\n\n\tobject_m = serialize(\n\t  {\n\t    brace_l_m,\n\t    or_empty(\n\t      serialize(\n\t        {\n\t          object_item_m,\n\t          or_empty(\n\t            one_or_more(\n\t              serialize(\n\t                {comma_m,object_item_m},\n\t                function(t) return t[1] end\n\t              )\n\t            )\n\t          )\n\t        },\n\t        function(t)\n\t          if t[2] then\n\t            table.insert(t[2],t[1])\n\t            return t[2]\n\t          else\n\t            return {t[1]}\n\t          end\n\t        end\n\t      )\n\t    ),\n\t    brace_r_m\n\t  },\n\t  function(t)\n\t    local o = {}\n\n\t    if t[1] then\n\t      for k,v in pairs(t[1]) do\n\t        o[v[1]] = v[2]\n\t      end\n\t    end\n\n\t    return o\n\t  end\n\t)\n\narray的描述，array需要保持一个状态index，如果直接用基本操作描述，传入的结果处理函数会比较蛋疼，所以用函数实现了。\n\n\t-- arrary\n\tlocal bracket_l_m = generator(\"%s*%[%s*\",nil_h)\n\tlocal bracket_r_m = generator(\"%s*%]%s*\",nil_h)\n\n\tarray_m = function(json_str, start)\n\n\t  local array,index = {}, 1\n\t  local add_item = function(v) array[index] = v[1]; index=index+1 end\n\t  local array_item_m = serialize({value_m},add_item)\n\n\t  local array_a = serialize{\n\t      bracket_l_m,\n\t      or_empty(\n\t        serialize{\n\t            array_item_m,\n\t            or_empty(\n\t              one_or_more(serialize{comma_m,array_item_m})\n\t                )\n\t              }\n\t          ),\n\t      bracket_r_m\n\t    }\n\n\t  local r,v,s = array_a(json_str,start)\n\t  return r,array,s\n\tend\n\n最后，匹配函数\n\n\tlocal function Marshal(json_str)\n\t  local result,value,start = value_m(json_str,1)\n\t  if result --and start == #json_str+1\n\t  then\n\t    return value\n\t  else\n\t    return nil, \"error_type\"\n\t  end\n\tend\n\nlua table 反解析成 json string 的比较直观，对每一种lua value类型写一个转换函数即可，此处不冗述。\n","slug":"Homework_Lua","published":1,"updated":"2016-11-26T16:48:02.000Z","_id":"civzfqild000hf66ozwp1hep0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>题目任务描述：封装json格式的数据与lua value间的互相转换功能</p>\n<p>下载ECMA-404的描述文件，观察json的数据格式。</p>\n<p>根据描述，一个json value可以是这些类型: object, array, number, string, true, false, or null。</p>\n<p><img src=\"/images/value.png\" alt=\"value\"></p>\n <a id=\"more\"></a>\n<p>下面是描述几种数据类型的图。</p>\n<p><img src=\"/images/object.png\" alt=\"object\"></p>\n<p><img src=\"/images/array.png\" alt=\"array\"></p>\n<p><img src=\"/images/number.png\" alt=\"number\"></p>\n<p><img src=\"/images/string.png\" alt=\"string\"></p>\n<p>这些图的描述能力应该等同BNF，所以需要处理的操作大概有：</p>\n<ol>\n<li>串联                    如，C等于A串联B(C＝AB)，即匹配一个C等同于匹配一个A接着匹配一个B</li>\n<li>并联                    如，C等于A并联A(C=A|B)，即匹配一个C等同于匹配一个A或者匹配一个B</li>\n<li>匹配0或1次            如，C等于匹配A0或1次(C=A?)，即匹配一个C等同于匹配一个A0或多次，该操作可以由 C=A|”” 代替，其中””表示空串。</li>\n<li>匹配0或任意次        如，C等于匹配A0或任意次(C=A*)，即匹配一个C等同于匹配一个A0或任意次</li>\n</ol>\n<p>则最简单的，上述的value可以描述成</p>\n<pre><code>value ＝ object | array | number | string | true | false | null\n</code></pre><p>object可以描述成，(引号内表示终结符，括号指示结合顺序)</p>\n<pre><code>object ＝ &quot;{&quot; ((string &quot;:&quot; value) (&quot;,&quot; string &quot;:&quot; value)*)? &quot;}&quot;\n</code></pre><p>其他就依次类推…</p>\n<hr>\n<p>回来开始写代码：</p>\n<p>先定义最简单的匹配函数的格式：</p>\n<pre><code>-- the matcher function\nfunction matcher(json_str, start)\n    ...\n    return result, value, new_start\nend\n</code></pre><p>最简单的匹配函数，接受一个待匹配的字符串和一个起始下标，返回匹配结果（true|false），匹配成功后的返回数据，一个新的起始下标。</p>\n<p>定义两个最简单的结果处理函数，一个不处理输入直接返回，另一个直接返回nil，后面会常用到</p>\n<pre><code>-- result handler\nlocal no_h = function(v) return v end\nlocal nil_h = function() return nil end\n</code></pre><p>定义一个生成基本匹配函数的生成函数，接受一个lua find的匹配表达式和一个结果处理函数，返回一个匹配函数。</p>\n<pre><code>-- matcher function generator\nlocal generator = function(pattern, handler)\n\n  -- the matcher function\n  function matcher(json_str, start)\n    local _, e = string.find(json_str, &quot;^&quot;..pattern, start)\n\n    if e then\n      return true, handler(string.sub(json_str, start, e)), e+1\n    else\n      return false, nil, start\n    end\n\n  end\n\n  return matcher\nend\n</code></pre><p>根据最开始的描述，需要的操作至少还有：并联、串联、匹配0或一次、匹配0或任意次。</p>\n<p>下面是并联多个匹配函数的并联操作，输入一个匹配函数列表和一个结果处理函数，返回一个并联后的匹配函数。</p>\n<pre><code>-- parallelize matchers\nparallelize = function(matchers,handler)\n  if handler == nil then\n    handler = no_h\n  end\n\n  -- the paralleized matcher function\n  function p_matcher(json_str, start)\n    local r,v,s\n\n    for i=1,#matchers do\n      r,v,s = matchers[i](json_str, start)\n      if r then\n        if handler == nil_h then return true, nil, s end\n        if handler == no_h then return true, v, s end\n        return r,handler(v),s\n      end\n    end\n\n    return false,nil,start\n  end\n\n  return p_matcher\nend\n</code></pre><p>下面是串联多个匹配函数的串联操作，输入一个匹配函数列表和一个结果处理函数，返回一个串联后的匹配函数。</p>\n<pre><code>-- serialize matchers\nserialize = function(matchers,handler)\n  if handler == nil then\n    handler = no_h\n  end\n\n  -- the serialized matcher function\n  function s_matcher(json_str, start)\n    local r,v,s = false,nil,start\n    local results = {}\n\n    for i=1,#matchers do\n      r,v,s = matchers[i](json_str, s)\n      if r == false then\n        return false,nil,start\n      end\n      table.insert(results,v)\n    end\n\n    if handler == nil_h then return true, nil, s end\n    if handler == no_h then return true, results, s end\n    return true,handler(results),s\n  end\n\n  return s_matcher\nend\n</code></pre><p>匹配0或任意次和匹配1或任意次之间存在转换关系，实现中选了1或任意次匹配作为原子操作，0或任意次可以描述为:(“”表示空串)</p>\n<pre><code>0_or_more = one_or_more | &quot;&quot;\n</code></pre><p>下面是1或任意次匹配操作，接受一个匹配函数和一个结果处理函数，返回一个匹配1次或任意次的匹配函数。</p>\n<pre><code>-- make a matcher match one or more\none_or_more = function(matcher, handler)\n  if handler == nil then\n    handler = function(v) return v end\n  end\n\n  -- the one or more matcher function\n  function oom_matcher(json_str, start)\n    local r,v,s = false,nil,start\n    local results = {}\n\n    r,v,s = matcher(json_str, s)\n    if r == false then\n      return false,nil,s\n    end\n    table.insert(results,v)\n\n    while true do\n      r,v,s = matcher(json_str, s)\n      if r == false then\n        break\n      end\n      table.insert(results,v)\n    end\n\n    if handler == nil_h then return true, nil, s end\n    if handler == no_h then return true, results, s end\n    return true,handler(results),s\n  end\n\n  return oom_matcher\nend\n</code></pre><p>下面定义了一个空串匹配函数，和定义一个0或1次匹配操作函数。</p>\n<pre><code>-- empty\nlocal empty_m = generator(&quot;&quot;,nil_h)\n\n-- or empty helper\nlocal or_empty = function(matcher)\n  return parallelize{matcher,empty_m}\nend\n</code></pre><p>定义完这些，就可以开始描述我们的匹配函数了。</p>\n<pre><code>-- main matchers\nlocal null_m, boolean_m, number_m, string_m, object_m, array_m, value_m, value_a\n</code></pre><p>value匹配函数的描述，value为number_m,string_m,boolean_m,null_m,object_m,array_m并联。</p>\n<pre><code>-- value\nvalue_m = function(json_str,s)\n  -- use value_a to bootup\n  if value_a==nil then\n    value_a = parallelize{number_m,string_m,boolean_m,null_m,object_m,array_m}\n  end\n  return value_a(json_str,s)\nend\n</code></pre><p>这里的value需要使用value_a来协助描述，因为代码最终会出现循环引用，此时number_m,string_m,boolean_m,null_m,object_m,array_m都还没定义，需要在定义好后，才能生成value的匹配函数。</p>\n<p>匹配null的函数，使用生成函数生成。</p>\n<pre><code>-- null\nnull_m = generator(&quot;null&quot;,function() return nil end)\n</code></pre><p>匹配boolean的函数，true和false使用生成函数生成，然后并联true和false匹配函数，生成boolean匹配函数。</p>\n<pre><code>-- boolean\nlocal true_m = generator(&quot;true&quot;, function() return true end)\nlocal false_m = generator(&quot;false&quot;, function() return false end)\nboolean_m = parallelize{true_m,false_m}\n</code></pre><p>匹配number的函数，根据最上面的图，描述为如下：</p>\n<pre><code>-- number\nlocal sign_m = generator(&quot;[+-]?&quot;,no_h)\nlocal minus_or_no_m = generator(&quot;[-]?&quot;,no_h)\nlocal number_no_0_m = generator(&quot;[1-9]%d*&quot;,no_h)\nlocal number_0_m = generator(&quot;0&quot;,no_h)\nlocal dot_number_m = generator(&quot;%.%d+&quot;,no_h)\nlocal e_number_m = generator(&quot;[eE][+-]?%d+&quot;,no_h)\n\nnumber_m = serialize(\n  {\n    minus_or_no_m,\n    parallelize{number_0_m,number_no_0_m},\n    or_empty(dot_number_m),\n    or_empty(e_number_m)\n  },\n  function(t) return tonumber(table.concat(t)) end\n  )\n</code></pre><p>string需要处理unicode2utf8编码转换及转义符号。</p>\n<p>unicode到utf8转换函数：</p>\n<pre><code>-- string\nlocal function hex2utf8(hex)\n  local v, utf8str = 0, &quot;&quot;  \n  v = tonumber(hex,16)\n  if v &gt;= 0x0800 then\n    utf8str = string.char(v%0x40+0x80)\n    v = math.modf(v/0x40)\n    vv = v % 0x40\n    utf8str = string.char(vv+0x80) .. utf8str\n    v = math.modf(v/0x40)\n    utf8str = string.char(v+0xe0) .. utf8str\n  elseif v &gt;= 0x0080 then\n    utf8str = string.char(v%0x40+0x80)\n    v = math.modf(v/0x40)\n    utf8str = string.char(v+0xc0) .. utf8str\n  else\n    utf8str = string.char(v)\n  end\n  return utf8str\nend\n</code></pre><p>匹配引号的函数，使用生成函数生成。</p>\n<pre><code>-- string\nlocal quotation_m = generator(&quot;\\&quot;&quot;,nil_h)\n</code></pre><p>匹配非”\\”字符的函数，生成函数生成。</p>\n<pre><code>local char_m = generator(&quot;[^\\&quot;\\\\]+&quot;, no_h)\n</code></pre><p>转义表</p>\n<pre><code>local escape_char = {\n    [&quot;\\&quot;&quot;] = &quot;\\&quot;&quot;,\n    [&quot;\\\\&quot;] = &quot;\\\\&quot;,\n    [&quot;/&quot;]  = &quot;/&quot;,\n    [&quot;b&quot;]  = &quot;\\b&quot;,\n    [&quot;f&quot;]  = &quot;\\f&quot;,\n    [&quot;n&quot;]  = &quot;\\n&quot;,\n    [&quot;r&quot;]  = &quot;\\r&quot;,\n    [&quot;t&quot;]  = &quot;\\t&quot;,\n  }\n</code></pre><p>匹配”\\”字符函数。</p>\n<pre><code>local backslash_m = generator(&quot;\\\\&quot;, nil_h)\n</code></pre><p>转义符号匹配和处理函数，注意传入的结果处理函数。</p>\n<pre><code>local escape_char_m = generator(&quot;[\\&quot;\\\\/bfnrt]&quot;,function(c) return escape_char[c] end)\n</code></pre><p>unicode匹配和处理函数，注意传入的结果处理函数。</p>\n<pre><code>local unicode_char_m = generator(&quot;u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]&quot;, function(v) return hex2utf8(string.sub(v,2)) end)\n</code></pre><p>string的描述</p>\n<pre><code>string_m = serialize(\n  {\n    quotation_m,\n    or_empty(\n        one_or_more(\n          parallelize{\n            char_m,\n            serialize(\n              {\n                backslash_m,\n                parallelize{escape_char_m,unicode_char_m}\n              },\n              table.concat\n              ),\n            },\n          table.concat\n          )\n      ),\n    quotation_m\n  },\n  table.concat\n)\n</code></pre><p>object的描述，各层结果处理函数比较复杂。</p>\n<pre><code>-- object\n-- brace_l\nlocal brace_l_m = generator(&quot;%s*{%s*&quot;,nil_h)\nlocal brace_r_m = generator(&quot;%s*}%s*&quot;,nil_h)\nlocal colon_m = generator(&quot;%s*:%s*&quot;,nil_h)\nlocal comma_m = generator(&quot;%s*,%s*&quot;,nil_h)\n\nlocal object_item_m = serialize{string_m,colon_m,value_m}\n\nobject_m = serialize(\n  {\n    brace_l_m,\n    or_empty(\n      serialize(\n        {\n          object_item_m,\n          or_empty(\n            one_or_more(\n              serialize(\n                {comma_m,object_item_m},\n                function(t) return t[1] end\n              )\n            )\n          )\n        },\n        function(t)\n          if t[2] then\n            table.insert(t[2],t[1])\n            return t[2]\n          else\n            return {t[1]}\n          end\n        end\n      )\n    ),\n    brace_r_m\n  },\n  function(t)\n    local o = {}\n\n    if t[1] then\n      for k,v in pairs(t[1]) do\n        o[v[1]] = v[2]\n      end\n    end\n\n    return o\n  end\n)\n</code></pre><p>array的描述，array需要保持一个状态index，如果直接用基本操作描述，传入的结果处理函数会比较蛋疼，所以用函数实现了。</p>\n<pre><code>-- arrary\nlocal bracket_l_m = generator(&quot;%s*%[%s*&quot;,nil_h)\nlocal bracket_r_m = generator(&quot;%s*%]%s*&quot;,nil_h)\n\narray_m = function(json_str, start)\n\n  local array,index = {}, 1\n  local add_item = function(v) array[index] = v[1]; index=index+1 end\n  local array_item_m = serialize({value_m},add_item)\n\n  local array_a = serialize{\n      bracket_l_m,\n      or_empty(\n        serialize{\n            array_item_m,\n            or_empty(\n              one_or_more(serialize{comma_m,array_item_m})\n                )\n              }\n          ),\n      bracket_r_m\n    }\n\n  local r,v,s = array_a(json_str,start)\n  return r,array,s\nend\n</code></pre><p>最后，匹配函数</p>\n<pre><code>local function Marshal(json_str)\n  local result,value,start = value_m(json_str,1)\n  if result --and start == #json_str+1\n  then\n    return value\n  else\n    return nil, &quot;error_type&quot;\n  end\nend\n</code></pre><p>lua table 反解析成 json string 的比较直观，对每一种lua value类型写一个转换函数即可，此处不冗述。</p>\n","excerpt":"<p>题目任务描述：封装json格式的数据与lua value间的互相转换功能</p>\n<p>下载ECMA-404的描述文件，观察json的数据格式。</p>\n<p>根据描述，一个json value可以是这些类型: object, array, number, string, true, false, or null。</p>\n<p><img src=\"/images/value.png\" alt=\"value\"></p>","more":"<p>下面是描述几种数据类型的图。</p>\n<p><img src=\"/images/object.png\" alt=\"object\"></p>\n<p><img src=\"/images/array.png\" alt=\"array\"></p>\n<p><img src=\"/images/number.png\" alt=\"number\"></p>\n<p><img src=\"/images/string.png\" alt=\"string\"></p>\n<p>这些图的描述能力应该等同BNF，所以需要处理的操作大概有：</p>\n<ol>\n<li>串联                    如，C等于A串联B(C＝AB)，即匹配一个C等同于匹配一个A接着匹配一个B</li>\n<li>并联                    如，C等于A并联A(C=A|B)，即匹配一个C等同于匹配一个A或者匹配一个B</li>\n<li>匹配0或1次            如，C等于匹配A0或1次(C=A?)，即匹配一个C等同于匹配一个A0或多次，该操作可以由 C=A|”” 代替，其中””表示空串。</li>\n<li>匹配0或任意次        如，C等于匹配A0或任意次(C=A*)，即匹配一个C等同于匹配一个A0或任意次</li>\n</ol>\n<p>则最简单的，上述的value可以描述成</p>\n<pre><code>value ＝ object | array | number | string | true | false | null\n</code></pre><p>object可以描述成，(引号内表示终结符，括号指示结合顺序)</p>\n<pre><code>object ＝ &quot;{&quot; ((string &quot;:&quot; value) (&quot;,&quot; string &quot;:&quot; value)*)? &quot;}&quot;\n</code></pre><p>其他就依次类推…</p>\n<hr>\n<p>回来开始写代码：</p>\n<p>先定义最简单的匹配函数的格式：</p>\n<pre><code>-- the matcher function\nfunction matcher(json_str, start)\n    ...\n    return result, value, new_start\nend\n</code></pre><p>最简单的匹配函数，接受一个待匹配的字符串和一个起始下标，返回匹配结果（true|false），匹配成功后的返回数据，一个新的起始下标。</p>\n<p>定义两个最简单的结果处理函数，一个不处理输入直接返回，另一个直接返回nil，后面会常用到</p>\n<pre><code>-- result handler\nlocal no_h = function(v) return v end\nlocal nil_h = function() return nil end\n</code></pre><p>定义一个生成基本匹配函数的生成函数，接受一个lua find的匹配表达式和一个结果处理函数，返回一个匹配函数。</p>\n<pre><code>-- matcher function generator\nlocal generator = function(pattern, handler)\n\n  -- the matcher function\n  function matcher(json_str, start)\n    local _, e = string.find(json_str, &quot;^&quot;..pattern, start)\n\n    if e then\n      return true, handler(string.sub(json_str, start, e)), e+1\n    else\n      return false, nil, start\n    end\n\n  end\n\n  return matcher\nend\n</code></pre><p>根据最开始的描述，需要的操作至少还有：并联、串联、匹配0或一次、匹配0或任意次。</p>\n<p>下面是并联多个匹配函数的并联操作，输入一个匹配函数列表和一个结果处理函数，返回一个并联后的匹配函数。</p>\n<pre><code>-- parallelize matchers\nparallelize = function(matchers,handler)\n  if handler == nil then\n    handler = no_h\n  end\n\n  -- the paralleized matcher function\n  function p_matcher(json_str, start)\n    local r,v,s\n\n    for i=1,#matchers do\n      r,v,s = matchers[i](json_str, start)\n      if r then\n        if handler == nil_h then return true, nil, s end\n        if handler == no_h then return true, v, s end\n        return r,handler(v),s\n      end\n    end\n\n    return false,nil,start\n  end\n\n  return p_matcher\nend\n</code></pre><p>下面是串联多个匹配函数的串联操作，输入一个匹配函数列表和一个结果处理函数，返回一个串联后的匹配函数。</p>\n<pre><code>-- serialize matchers\nserialize = function(matchers,handler)\n  if handler == nil then\n    handler = no_h\n  end\n\n  -- the serialized matcher function\n  function s_matcher(json_str, start)\n    local r,v,s = false,nil,start\n    local results = {}\n\n    for i=1,#matchers do\n      r,v,s = matchers[i](json_str, s)\n      if r == false then\n        return false,nil,start\n      end\n      table.insert(results,v)\n    end\n\n    if handler == nil_h then return true, nil, s end\n    if handler == no_h then return true, results, s end\n    return true,handler(results),s\n  end\n\n  return s_matcher\nend\n</code></pre><p>匹配0或任意次和匹配1或任意次之间存在转换关系，实现中选了1或任意次匹配作为原子操作，0或任意次可以描述为:(“”表示空串)</p>\n<pre><code>0_or_more = one_or_more | &quot;&quot;\n</code></pre><p>下面是1或任意次匹配操作，接受一个匹配函数和一个结果处理函数，返回一个匹配1次或任意次的匹配函数。</p>\n<pre><code>-- make a matcher match one or more\none_or_more = function(matcher, handler)\n  if handler == nil then\n    handler = function(v) return v end\n  end\n\n  -- the one or more matcher function\n  function oom_matcher(json_str, start)\n    local r,v,s = false,nil,start\n    local results = {}\n\n    r,v,s = matcher(json_str, s)\n    if r == false then\n      return false,nil,s\n    end\n    table.insert(results,v)\n\n    while true do\n      r,v,s = matcher(json_str, s)\n      if r == false then\n        break\n      end\n      table.insert(results,v)\n    end\n\n    if handler == nil_h then return true, nil, s end\n    if handler == no_h then return true, results, s end\n    return true,handler(results),s\n  end\n\n  return oom_matcher\nend\n</code></pre><p>下面定义了一个空串匹配函数，和定义一个0或1次匹配操作函数。</p>\n<pre><code>-- empty\nlocal empty_m = generator(&quot;&quot;,nil_h)\n\n-- or empty helper\nlocal or_empty = function(matcher)\n  return parallelize{matcher,empty_m}\nend\n</code></pre><p>定义完这些，就可以开始描述我们的匹配函数了。</p>\n<pre><code>-- main matchers\nlocal null_m, boolean_m, number_m, string_m, object_m, array_m, value_m, value_a\n</code></pre><p>value匹配函数的描述，value为number_m,string_m,boolean_m,null_m,object_m,array_m并联。</p>\n<pre><code>-- value\nvalue_m = function(json_str,s)\n  -- use value_a to bootup\n  if value_a==nil then\n    value_a = parallelize{number_m,string_m,boolean_m,null_m,object_m,array_m}\n  end\n  return value_a(json_str,s)\nend\n</code></pre><p>这里的value需要使用value_a来协助描述，因为代码最终会出现循环引用，此时number_m,string_m,boolean_m,null_m,object_m,array_m都还没定义，需要在定义好后，才能生成value的匹配函数。</p>\n<p>匹配null的函数，使用生成函数生成。</p>\n<pre><code>-- null\nnull_m = generator(&quot;null&quot;,function() return nil end)\n</code></pre><p>匹配boolean的函数，true和false使用生成函数生成，然后并联true和false匹配函数，生成boolean匹配函数。</p>\n<pre><code>-- boolean\nlocal true_m = generator(&quot;true&quot;, function() return true end)\nlocal false_m = generator(&quot;false&quot;, function() return false end)\nboolean_m = parallelize{true_m,false_m}\n</code></pre><p>匹配number的函数，根据最上面的图，描述为如下：</p>\n<pre><code>-- number\nlocal sign_m = generator(&quot;[+-]?&quot;,no_h)\nlocal minus_or_no_m = generator(&quot;[-]?&quot;,no_h)\nlocal number_no_0_m = generator(&quot;[1-9]%d*&quot;,no_h)\nlocal number_0_m = generator(&quot;0&quot;,no_h)\nlocal dot_number_m = generator(&quot;%.%d+&quot;,no_h)\nlocal e_number_m = generator(&quot;[eE][+-]?%d+&quot;,no_h)\n\nnumber_m = serialize(\n  {\n    minus_or_no_m,\n    parallelize{number_0_m,number_no_0_m},\n    or_empty(dot_number_m),\n    or_empty(e_number_m)\n  },\n  function(t) return tonumber(table.concat(t)) end\n  )\n</code></pre><p>string需要处理unicode2utf8编码转换及转义符号。</p>\n<p>unicode到utf8转换函数：</p>\n<pre><code>-- string\nlocal function hex2utf8(hex)\n  local v, utf8str = 0, &quot;&quot;  \n  v = tonumber(hex,16)\n  if v &gt;= 0x0800 then\n    utf8str = string.char(v%0x40+0x80)\n    v = math.modf(v/0x40)\n    vv = v % 0x40\n    utf8str = string.char(vv+0x80) .. utf8str\n    v = math.modf(v/0x40)\n    utf8str = string.char(v+0xe0) .. utf8str\n  elseif v &gt;= 0x0080 then\n    utf8str = string.char(v%0x40+0x80)\n    v = math.modf(v/0x40)\n    utf8str = string.char(v+0xc0) .. utf8str\n  else\n    utf8str = string.char(v)\n  end\n  return utf8str\nend\n</code></pre><p>匹配引号的函数，使用生成函数生成。</p>\n<pre><code>-- string\nlocal quotation_m = generator(&quot;\\&quot;&quot;,nil_h)\n</code></pre><p>匹配非”\\”字符的函数，生成函数生成。</p>\n<pre><code>local char_m = generator(&quot;[^\\&quot;\\\\]+&quot;, no_h)\n</code></pre><p>转义表</p>\n<pre><code>local escape_char = {\n    [&quot;\\&quot;&quot;] = &quot;\\&quot;&quot;,\n    [&quot;\\\\&quot;] = &quot;\\\\&quot;,\n    [&quot;/&quot;]  = &quot;/&quot;,\n    [&quot;b&quot;]  = &quot;\\b&quot;,\n    [&quot;f&quot;]  = &quot;\\f&quot;,\n    [&quot;n&quot;]  = &quot;\\n&quot;,\n    [&quot;r&quot;]  = &quot;\\r&quot;,\n    [&quot;t&quot;]  = &quot;\\t&quot;,\n  }\n</code></pre><p>匹配”\\”字符函数。</p>\n<pre><code>local backslash_m = generator(&quot;\\\\&quot;, nil_h)\n</code></pre><p>转义符号匹配和处理函数，注意传入的结果处理函数。</p>\n<pre><code>local escape_char_m = generator(&quot;[\\&quot;\\\\/bfnrt]&quot;,function(c) return escape_char[c] end)\n</code></pre><p>unicode匹配和处理函数，注意传入的结果处理函数。</p>\n<pre><code>local unicode_char_m = generator(&quot;u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]&quot;, function(v) return hex2utf8(string.sub(v,2)) end)\n</code></pre><p>string的描述</p>\n<pre><code>string_m = serialize(\n  {\n    quotation_m,\n    or_empty(\n        one_or_more(\n          parallelize{\n            char_m,\n            serialize(\n              {\n                backslash_m,\n                parallelize{escape_char_m,unicode_char_m}\n              },\n              table.concat\n              ),\n            },\n          table.concat\n          )\n      ),\n    quotation_m\n  },\n  table.concat\n)\n</code></pre><p>object的描述，各层结果处理函数比较复杂。</p>\n<pre><code>-- object\n-- brace_l\nlocal brace_l_m = generator(&quot;%s*{%s*&quot;,nil_h)\nlocal brace_r_m = generator(&quot;%s*}%s*&quot;,nil_h)\nlocal colon_m = generator(&quot;%s*:%s*&quot;,nil_h)\nlocal comma_m = generator(&quot;%s*,%s*&quot;,nil_h)\n\nlocal object_item_m = serialize{string_m,colon_m,value_m}\n\nobject_m = serialize(\n  {\n    brace_l_m,\n    or_empty(\n      serialize(\n        {\n          object_item_m,\n          or_empty(\n            one_or_more(\n              serialize(\n                {comma_m,object_item_m},\n                function(t) return t[1] end\n              )\n            )\n          )\n        },\n        function(t)\n          if t[2] then\n            table.insert(t[2],t[1])\n            return t[2]\n          else\n            return {t[1]}\n          end\n        end\n      )\n    ),\n    brace_r_m\n  },\n  function(t)\n    local o = {}\n\n    if t[1] then\n      for k,v in pairs(t[1]) do\n        o[v[1]] = v[2]\n      end\n    end\n\n    return o\n  end\n)\n</code></pre><p>array的描述，array需要保持一个状态index，如果直接用基本操作描述，传入的结果处理函数会比较蛋疼，所以用函数实现了。</p>\n<pre><code>-- arrary\nlocal bracket_l_m = generator(&quot;%s*%[%s*&quot;,nil_h)\nlocal bracket_r_m = generator(&quot;%s*%]%s*&quot;,nil_h)\n\narray_m = function(json_str, start)\n\n  local array,index = {}, 1\n  local add_item = function(v) array[index] = v[1]; index=index+1 end\n  local array_item_m = serialize({value_m},add_item)\n\n  local array_a = serialize{\n      bracket_l_m,\n      or_empty(\n        serialize{\n            array_item_m,\n            or_empty(\n              one_or_more(serialize{comma_m,array_item_m})\n                )\n              }\n          ),\n      bracket_r_m\n    }\n\n  local r,v,s = array_a(json_str,start)\n  return r,array,s\nend\n</code></pre><p>最后，匹配函数</p>\n<pre><code>local function Marshal(json_str)\n  local result,value,start = value_m(json_str,1)\n  if result --and start == #json_str+1\n  then\n    return value\n  else\n    return nil, &quot;error_type&quot;\n  end\nend\n</code></pre><p>lua table 反解析成 json string 的比较直观，对每一种lua value类型写一个转换函数即可，此处不冗述。</p>"},{"title":"U3D iOS SDK Wrapper","date":"2014-08-17T10:47:54.000Z","_content":"\n很多游戏使用U3D引擎，比如《忍者必须死》、《影之刃》... 所以，iOS NtUniSDK需要一个U3D的wrapper。\n\nU3D的C#可以调用外部C接口，故需要为NtUniSDK包装一个C语言层，下面给出简化的项目示例代码。\n\n <!-- more --> \n\n\t#import \"UnityAppController.h\"\n\n\t#import \"UniHead.h\"\n\n\t#pragma mark __NtNotificationWrapper\n\n\t#define GameObject \"Main Camera\"\n\n\t#if defined(__cplusplus)\n\textern \"C\"{\n\t#endif\n    \textern void UnitySendMessage(const char *, const char *, const char *);\n\t#if defined(__cplusplus)\n\t}\n\t#endif\n\n\n\t@interface __NtNotificationWrapper : NSObject\n\t@end\n\t\n\tstatic __NtNotificationWrapper *__inst = nil;\n\n\t@implementation __NtNotificationWrapper\n\n\t+ (void) initialize\n\t{\n    \tif (__inst) {\n        \treturn;\n    \t}\n    \n    \t__inst = [[__NtNotificationWrapper alloc] init];\n    \n    \t//初始化通知\n    \t[[NSNotificationCenter defaultCenter] addObserver:__inst selector:@selector(finishInitNotification:) name:NT_NOTIFICATION_FINISH_INIT object:nil];\n    \n\t}\n\n\n\t//初始化完成处理\n\t- (void)finishInitNotification:(NSNotification *)notification\n\t{\n   \t\tNSLog(@\"[NtUniSdk] Notification finishInit.\");\n    \tUnitySendMessage(GameObject,\"NT_NOTIFICATION_FINISH_INIT\",\"\");\n\t}\n\n\t\n\t+ (void) doNothing{}\n\n\t@end\n\n\n\t#pragma mark - __NtSdkMgr_X\n\n\t#if defined(__cplusplus)\n\textern \"C\"{\n\t#endif\n\n    char* __makeCString(NSString* string)\n    {\n        if (string == nil) {\n            return NULL;\n        }\n        \n        const char* cstring = [string cStringUsingEncoding:NSUTF8StringEncoding];\n        \n        if (NULL == cstring) {\n            return NULL;\n        }\n        char* res = (char*)malloc(strlen(cstring)+1);\n        strcpy(res, cstring);\n        return res;\n    }\n       \n    NSString* __makeNSString(const char* cstring)\n    {\n        if (cstring == NULL) {\n            return nil;\n        }\n            \n        NSString* nsstring = [[NSString alloc] initWithCString:cstring encoding:NSUTF8StringEncoding];\n        \n        return nsstring;\n    }\n        \n    void __NtSdkMgr_ntInit()\n    {\n        [__NtNotificationWrapper doNothing];\n        [NtSdkMgr ntInit];\n    }\n\t\n\t#if defined(__cplusplus)\n\t}\n\t#endif\n\t\n注意上述代码中，对Notification的传递使用了\n\n\textern void UnitySendMessage(const char *, const char *, const char *);\n\n调用GameObject上的回调函数。\n\n回到U3D，新建一个C#文件，实现SDK的C# Wrapper。下面是简化的代码示例：\n\n\n\tusing UnityEngine;\n\n\tusing System;\n\tusing System.Collections;\n\tusing System.Collections.Generic;\n\tusing System.Runtime.InteropServices;\n\tusing System.Text;\n\n\tnamespace NtUniSdk{\n\t\tnamespace Unity3d{ \n\t\t\tpublic class SdkU3d : MonoBehaviour\n\t\t\t{\n\n\t\t\t\tpublic static void ntInit()\n\t\t\t\t{\n\t\t\t\t\t__NtSdkMgr_ntInit();\n\t\t\t\t}\n\n\t\t\t\t[DllImport(\"__Internal\")]\n\t\t\t\tprivate static extern void __NtSdkMgr_ntInit();\n\t\t\t\n\t\t\t};\n\n\t\t}\n\t}\n\n在U3D中即可使用该Wrapper操作SDK。\n\n在U3D中将工程导出为Xcode工程，向Xcode中添加上述完成的C包装层，同时，按文档正常接入NtUniSDK。\n","source":"_posts/U3D_iOS_Wrapper.md","raw":"title: U3D iOS SDK Wrapper\ndate: 2014-08-17 18:47:54\ntags: [U3D,iOS,SDK]\n---\n\n很多游戏使用U3D引擎，比如《忍者必须死》、《影之刃》... 所以，iOS NtUniSDK需要一个U3D的wrapper。\n\nU3D的C#可以调用外部C接口，故需要为NtUniSDK包装一个C语言层，下面给出简化的项目示例代码。\n\n <!-- more --> \n\n\t#import \"UnityAppController.h\"\n\n\t#import \"UniHead.h\"\n\n\t#pragma mark __NtNotificationWrapper\n\n\t#define GameObject \"Main Camera\"\n\n\t#if defined(__cplusplus)\n\textern \"C\"{\n\t#endif\n    \textern void UnitySendMessage(const char *, const char *, const char *);\n\t#if defined(__cplusplus)\n\t}\n\t#endif\n\n\n\t@interface __NtNotificationWrapper : NSObject\n\t@end\n\t\n\tstatic __NtNotificationWrapper *__inst = nil;\n\n\t@implementation __NtNotificationWrapper\n\n\t+ (void) initialize\n\t{\n    \tif (__inst) {\n        \treturn;\n    \t}\n    \n    \t__inst = [[__NtNotificationWrapper alloc] init];\n    \n    \t//初始化通知\n    \t[[NSNotificationCenter defaultCenter] addObserver:__inst selector:@selector(finishInitNotification:) name:NT_NOTIFICATION_FINISH_INIT object:nil];\n    \n\t}\n\n\n\t//初始化完成处理\n\t- (void)finishInitNotification:(NSNotification *)notification\n\t{\n   \t\tNSLog(@\"[NtUniSdk] Notification finishInit.\");\n    \tUnitySendMessage(GameObject,\"NT_NOTIFICATION_FINISH_INIT\",\"\");\n\t}\n\n\t\n\t+ (void) doNothing{}\n\n\t@end\n\n\n\t#pragma mark - __NtSdkMgr_X\n\n\t#if defined(__cplusplus)\n\textern \"C\"{\n\t#endif\n\n    char* __makeCString(NSString* string)\n    {\n        if (string == nil) {\n            return NULL;\n        }\n        \n        const char* cstring = [string cStringUsingEncoding:NSUTF8StringEncoding];\n        \n        if (NULL == cstring) {\n            return NULL;\n        }\n        char* res = (char*)malloc(strlen(cstring)+1);\n        strcpy(res, cstring);\n        return res;\n    }\n       \n    NSString* __makeNSString(const char* cstring)\n    {\n        if (cstring == NULL) {\n            return nil;\n        }\n            \n        NSString* nsstring = [[NSString alloc] initWithCString:cstring encoding:NSUTF8StringEncoding];\n        \n        return nsstring;\n    }\n        \n    void __NtSdkMgr_ntInit()\n    {\n        [__NtNotificationWrapper doNothing];\n        [NtSdkMgr ntInit];\n    }\n\t\n\t#if defined(__cplusplus)\n\t}\n\t#endif\n\t\n注意上述代码中，对Notification的传递使用了\n\n\textern void UnitySendMessage(const char *, const char *, const char *);\n\n调用GameObject上的回调函数。\n\n回到U3D，新建一个C#文件，实现SDK的C# Wrapper。下面是简化的代码示例：\n\n\n\tusing UnityEngine;\n\n\tusing System;\n\tusing System.Collections;\n\tusing System.Collections.Generic;\n\tusing System.Runtime.InteropServices;\n\tusing System.Text;\n\n\tnamespace NtUniSdk{\n\t\tnamespace Unity3d{ \n\t\t\tpublic class SdkU3d : MonoBehaviour\n\t\t\t{\n\n\t\t\t\tpublic static void ntInit()\n\t\t\t\t{\n\t\t\t\t\t__NtSdkMgr_ntInit();\n\t\t\t\t}\n\n\t\t\t\t[DllImport(\"__Internal\")]\n\t\t\t\tprivate static extern void __NtSdkMgr_ntInit();\n\t\t\t\n\t\t\t};\n\n\t\t}\n\t}\n\n在U3D中即可使用该Wrapper操作SDK。\n\n在U3D中将工程导出为Xcode工程，向Xcode中添加上述完成的C包装层，同时，按文档正常接入NtUniSDK。\n","slug":"U3D_iOS_Wrapper","published":1,"updated":"2016-08-08T11:42:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civzfqilf000jf66obshcqcli","content":"<p>很多游戏使用U3D引擎，比如《忍者必须死》、《影之刃》… 所以，iOS NtUniSDK需要一个U3D的wrapper。</p>\n<p>U3D的C#可以调用外部C接口，故需要为NtUniSDK包装一个C语言层，下面给出简化的项目示例代码。</p>\n <a id=\"more\"></a> \n<pre><code>#import &quot;UnityAppController.h&quot;\n\n#import &quot;UniHead.h&quot;\n\n#pragma mark __NtNotificationWrapper\n\n#define GameObject &quot;Main Camera&quot;\n\n#if defined(__cplusplus)\nextern &quot;C&quot;{\n#endif\n    extern void UnitySendMessage(const char *, const char *, const char *);\n#if defined(__cplusplus)\n}\n#endif\n\n\n@interface __NtNotificationWrapper : NSObject\n@end\n\nstatic __NtNotificationWrapper *__inst = nil;\n\n@implementation __NtNotificationWrapper\n\n+ (void) initialize\n{\n    if (__inst) {\n        return;\n    }\n\n    __inst = [[__NtNotificationWrapper alloc] init];\n\n    //初始化通知\n    [[NSNotificationCenter defaultCenter] addObserver:__inst selector:@selector(finishInitNotification:) name:NT_NOTIFICATION_FINISH_INIT object:nil];\n\n}\n\n\n//初始化完成处理\n- (void)finishInitNotification:(NSNotification *)notification\n{\n       NSLog(@&quot;[NtUniSdk] Notification finishInit.&quot;);\n    UnitySendMessage(GameObject,&quot;NT_NOTIFICATION_FINISH_INIT&quot;,&quot;&quot;);\n}\n\n\n+ (void) doNothing{}\n\n@end\n\n\n#pragma mark - __NtSdkMgr_X\n\n#if defined(__cplusplus)\nextern &quot;C&quot;{\n#endif\n\nchar* __makeCString(NSString* string)\n{\n    if (string == nil) {\n        return NULL;\n    }\n\n    const char* cstring = [string cStringUsingEncoding:NSUTF8StringEncoding];\n\n    if (NULL == cstring) {\n        return NULL;\n    }\n    char* res = (char*)malloc(strlen(cstring)+1);\n    strcpy(res, cstring);\n    return res;\n}\n\nNSString* __makeNSString(const char* cstring)\n{\n    if (cstring == NULL) {\n        return nil;\n    }\n\n    NSString* nsstring = [[NSString alloc] initWithCString:cstring encoding:NSUTF8StringEncoding];\n\n    return nsstring;\n}\n\nvoid __NtSdkMgr_ntInit()\n{\n    [__NtNotificationWrapper doNothing];\n    [NtSdkMgr ntInit];\n}\n\n#if defined(__cplusplus)\n}\n#endif\n</code></pre><p>注意上述代码中，对Notification的传递使用了</p>\n<pre><code>extern void UnitySendMessage(const char *, const char *, const char *);\n</code></pre><p>调用GameObject上的回调函数。</p>\n<p>回到U3D，新建一个C#文件，实现SDK的C# Wrapper。下面是简化的代码示例：</p>\n<pre><code>using UnityEngine;\n\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Text;\n\nnamespace NtUniSdk{\n    namespace Unity3d{ \n        public class SdkU3d : MonoBehaviour\n        {\n\n            public static void ntInit()\n            {\n                __NtSdkMgr_ntInit();\n            }\n\n            [DllImport(&quot;__Internal&quot;)]\n            private static extern void __NtSdkMgr_ntInit();\n\n        };\n\n    }\n}\n</code></pre><p>在U3D中即可使用该Wrapper操作SDK。</p>\n<p>在U3D中将工程导出为Xcode工程，向Xcode中添加上述完成的C包装层，同时，按文档正常接入NtUniSDK。</p>\n","excerpt":"<p>很多游戏使用U3D引擎，比如《忍者必须死》、《影之刃》… 所以，iOS NtUniSDK需要一个U3D的wrapper。</p>\n<p>U3D的C#可以调用外部C接口，故需要为NtUniSDK包装一个C语言层，下面给出简化的项目示例代码。</p>","more":"<pre><code>#import &quot;UnityAppController.h&quot;\n\n#import &quot;UniHead.h&quot;\n\n#pragma mark __NtNotificationWrapper\n\n#define GameObject &quot;Main Camera&quot;\n\n#if defined(__cplusplus)\nextern &quot;C&quot;{\n#endif\n    extern void UnitySendMessage(const char *, const char *, const char *);\n#if defined(__cplusplus)\n}\n#endif\n\n\n@interface __NtNotificationWrapper : NSObject\n@end\n\nstatic __NtNotificationWrapper *__inst = nil;\n\n@implementation __NtNotificationWrapper\n\n+ (void) initialize\n{\n    if (__inst) {\n        return;\n    }\n\n    __inst = [[__NtNotificationWrapper alloc] init];\n\n    //初始化通知\n    [[NSNotificationCenter defaultCenter] addObserver:__inst selector:@selector(finishInitNotification:) name:NT_NOTIFICATION_FINISH_INIT object:nil];\n\n}\n\n\n//初始化完成处理\n- (void)finishInitNotification:(NSNotification *)notification\n{\n       NSLog(@&quot;[NtUniSdk] Notification finishInit.&quot;);\n    UnitySendMessage(GameObject,&quot;NT_NOTIFICATION_FINISH_INIT&quot;,&quot;&quot;);\n}\n\n\n+ (void) doNothing{}\n\n@end\n\n\n#pragma mark - __NtSdkMgr_X\n\n#if defined(__cplusplus)\nextern &quot;C&quot;{\n#endif\n\nchar* __makeCString(NSString* string)\n{\n    if (string == nil) {\n        return NULL;\n    }\n\n    const char* cstring = [string cStringUsingEncoding:NSUTF8StringEncoding];\n\n    if (NULL == cstring) {\n        return NULL;\n    }\n    char* res = (char*)malloc(strlen(cstring)+1);\n    strcpy(res, cstring);\n    return res;\n}\n\nNSString* __makeNSString(const char* cstring)\n{\n    if (cstring == NULL) {\n        return nil;\n    }\n\n    NSString* nsstring = [[NSString alloc] initWithCString:cstring encoding:NSUTF8StringEncoding];\n\n    return nsstring;\n}\n\nvoid __NtSdkMgr_ntInit()\n{\n    [__NtNotificationWrapper doNothing];\n    [NtSdkMgr ntInit];\n}\n\n#if defined(__cplusplus)\n}\n#endif\n</code></pre><p>注意上述代码中，对Notification的传递使用了</p>\n<pre><code>extern void UnitySendMessage(const char *, const char *, const char *);\n</code></pre><p>调用GameObject上的回调函数。</p>\n<p>回到U3D，新建一个C#文件，实现SDK的C# Wrapper。下面是简化的代码示例：</p>\n<pre><code>using UnityEngine;\n\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Text;\n\nnamespace NtUniSdk{\n    namespace Unity3d{ \n        public class SdkU3d : MonoBehaviour\n        {\n\n            public static void ntInit()\n            {\n                __NtSdkMgr_ntInit();\n            }\n\n            [DllImport(&quot;__Internal&quot;)]\n            private static extern void __NtSdkMgr_ntInit();\n\n        };\n\n    }\n}\n</code></pre><p>在U3D中即可使用该Wrapper操作SDK。</p>\n<p>在U3D中将工程导出为Xcode工程，向Xcode中添加上述完成的C包装层，同时，按文档正常接入NtUniSDK。</p>"},{"title":"生存技能 01. Markdown & LaTexFormulas","date":"2016-11-26T16:21:11.000Z","_content":"","source":"_posts/Survival_Skill_Markdown_and_LaTex_Formulas.md","raw":"title: 生存技能 01. Markdown & LaTexFormulas\ndate: 2016-11-27 00:21:11\ntags: [Survival Skill, Markdown, LaTex]\n---\n","slug":"Survival_Skill_Markdown_and_LaTex_Formulas","published":1,"updated":"2016-11-26T16:49:15.000Z","_id":"civzgc1ss002kf66ok073hyfa","comments":1,"layout":"post","photos":[],"link":"","content":"","excerpt":"","more":""}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"civzfqiku0005f66od8dn4kkm","tag_id":"civzfqilf000if66ogh4v3xg9","_id":"civzfqilm000of66onfho4kly"},{"post_id":"civzfqiku0005f66od8dn4kkm","tag_id":"civzfqili000lf66ok85kel1g","_id":"civzfqilm000pf66orqsc5qr2"},{"post_id":"civzfqiku0005f66od8dn4kkm","tag_id":"civzfqiko0004f66o7oeyhe1w","_id":"civzfqiln000rf66ovr0mnhbl"},{"post_id":"civzfqikz0007f66oxhbbuvyf","tag_id":"civzfqill000nf66ooebpomog","_id":"civzfqilo000uf66ogtoxslff"},{"post_id":"civzfqikz0007f66oxhbbuvyf","tag_id":"civzfqilm000qf66o3p224yji","_id":"civzfqilo000vf66ou7neg5cy"},{"post_id":"civzfqikz0007f66oxhbbuvyf","tag_id":"civzfqiln000sf66oj84xg786","_id":"civzfqilp000xf66okt1j9m7h"},{"post_id":"civzfqil10009f66okg6snkfa","tag_id":"civzfqilf000if66ogh4v3xg9","_id":"civzfqils000zf66olxappzx2"},{"post_id":"civzfqil10009f66okg6snkfa","tag_id":"civzfqili000lf66ok85kel1g","_id":"civzfqilt0010f66odalvjzvg"},{"post_id":"civzfqil10009f66okg6snkfa","tag_id":"civzfqiko0004f66o7oeyhe1w","_id":"civzfqilt0012f66of0a2mo2g"},{"post_id":"civzfqil3000af66oc4civkh5","tag_id":"civzfqill000nf66ooebpomog","_id":"civzfqilu0016f66ofzmdluid"},{"post_id":"civzfqil3000af66oc4civkh5","tag_id":"civzfqilt0011f66okvm23njt","_id":"civzfqilu0017f66o2u50bybp"},{"post_id":"civzfqil3000af66oc4civkh5","tag_id":"civzfqilt0013f66okevmd0jl","_id":"civzfqilv0019f66oj2si9l7g"},{"post_id":"civzfqil3000af66oc4civkh5","tag_id":"civzfqilu0014f66ovzu4w5xh","_id":"civzfqilv001af66ojtypcfn9"},{"post_id":"civzfqil6000bf66oyoa4z9hq","tag_id":"civzfqilu0015f66ousm6addw","_id":"civzfqilw001cf66o3n6bqvg0"},{"post_id":"civzfqil6000bf66oyoa4z9hq","tag_id":"civzfqilu0018f66o522bvtqx","_id":"civzfqilw001df66o0ddal49p"},{"post_id":"civzfqil9000ff66opt2q7zgg","tag_id":"civzfqilw001bf66orkds4evi","_id":"civzfqilx001hf66o9o2922xg"},{"post_id":"civzfqild000hf66ozwp1hep0","tag_id":"civzfqilx001gf66op0foxvdr","_id":"civzfqim0001nf66oi9b0tph4"},{"post_id":"civzfqild000hf66ozwp1hep0","tag_id":"civzfqily001jf66oeeijbtvq","_id":"civzfqim0001of66ocl6037u2"},{"post_id":"civzfqilf000jf66obshcqcli","tag_id":"civzfqilz001mf66oxazsxp4v","_id":"civzfqim3001sf66okoq4t9c7"},{"post_id":"civzfqilf000jf66obshcqcli","tag_id":"civzfqill000nf66ooebpomog","_id":"civzfqim3001tf66ozna5tjq9"},{"post_id":"civzfqilf000jf66obshcqcli","tag_id":"civzfqilt0011f66okvm23njt","_id":"civzfqim3001uf66o7tnqtx8h"},{"post_id":"civzfqikm0003f66ovj6ayvp0","tag_id":"civzg8uyx0021f66o5mivfj1k","_id":"civzg8uyx0022f66ozbdets39"},{"post_id":"civzfqikd0001f66otnqkgjp6","tag_id":"civzfqiko0004f66o7oeyhe1w","_id":"civzg9oia0025f66omscd5jyv"},{"post_id":"civzfqikd0001f66otnqkgjp6","tag_id":"civzfqil00008f66o5h8hei85","_id":"civzg9oia0026f66onn6i79hs"},{"post_id":"civzfqil9000ff66opt2q7zgg","tag_id":"civzfqiko0004f66o7oeyhe1w","_id":"civzgaakx0028f66opayua66g"},{"post_id":"civzfqil9000ff66opt2q7zgg","tag_id":"civzgaakx0027f66ocqgtywoo","_id":"civzgaakx0029f66o17ja1vam"},{"post_id":"civzfqild000hf66ozwp1hep0","tag_id":"civzgafor002af66orr7rjqck","_id":"civzgafos002bf66o389d8cvz"},{"post_id":"civzgc1ss002kf66ok073hyfa","tag_id":"civzgaz42002cf66o7hk5br3t","_id":"civzgc1su002lf66obaa2kt7u"},{"post_id":"civzgc1ss002kf66ok073hyfa","tag_id":"civzgaz43002df66outm2ayrv","_id":"civzgc1su002mf66o2ni22gd0"},{"post_id":"civzgc1ss002kf66ok073hyfa","tag_id":"civzgbj1y002if66o0vceh4lh","_id":"civzgc1sv002nf66o4dd8193u"}],"Tag":[{"name":"Game","_id":"civzfqiko0004f66o7oeyhe1w"},{"name":"Work","_id":"civzfqil00008f66o5h8hei85"},{"name":"Daily","_id":"civzfqil8000cf66ox7l5u480"},{"name":"Recast & Detour","_id":"civzfqilf000if66ogh4v3xg9"},{"name":"NavMesh","_id":"civzfqili000lf66ok85kel1g"},{"name":"iOS","_id":"civzfqill000nf66ooebpomog"},{"name":"IAP","_id":"civzfqilm000qf66o3p224yji"},{"name":"Receipt","_id":"civzfqiln000sf66oj84xg786"},{"name":"SDK","_id":"civzfqilt0011f66okvm23njt"},{"name":"Flash","_id":"civzfqilt0013f66okevmd0jl"},{"name":"ANE","_id":"civzfqilu0014f66ovzu4w5xh"},{"name":"Xcode","_id":"civzfqilu0015f66ousm6addw"},{"name":"Plugin","_id":"civzfqilu0018f66o522bvtqx"},{"name":"Extra Credits","_id":"civzfqilw001bf66orkds4evi"},{"name":"game","_id":"civzfqilw001ef66orke3in8g"},{"name":"video lesson series","_id":"civzfqilx001ff66ofb31w8wa"},{"name":"lua","_id":"civzfqilx001gf66op0foxvdr"},{"name":"json","_id":"civzfqily001jf66oeeijbtvq"},{"name":"parser","_id":"civzfqilz001lf66our2ywd11"},{"name":"U3D","_id":"civzfqilz001mf66oxazsxp4v"},{"name":"work","_id":"civzg8ne5001wf66o5r9l00d5"},{"name":"begin","_id":"civzg8ne6001xf66oj2hbu02v"},{"name":"daily","_id":"civzg8uyx0021f66o5mivfj1k"},{"name":"Video Lesson Series","_id":"civzgaakx0027f66ocqgtywoo"},{"name":"Parser","_id":"civzgafor002af66orr7rjqck"},{"name":"Survival Skill","_id":"civzgaz42002cf66o7hk5br3t"},{"name":"Markdown","_id":"civzgaz43002df66outm2ayrv"},{"name":"Latex","_id":"civzgaz43002ef66oarm49dc9"},{"name":"LaTex","_id":"civzgbj1y002if66o0vceh4lh"}]}}